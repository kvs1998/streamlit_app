    st.header("Global Filter Canvas")
    st.write("Set high-level filters here to apply across all relevant dashboard tabs. Each dashboard tab can apply further refinements.")

    # --- Initialize Session State for ALL Global Filters ---
    # These explicit initializations ensure keys exist for render logic.
    # This block should be at the very top of app_driver.py for ultimate persistence.
    if 'global_domain_name' not in st.session_state: st.session_state.global_domain_name = 'All'
    if 'global_sub_domain_name' not in st.session_state: st.session_state.global_sub_domain_name = 'All'
    if 'global_db_filter' not in st.session_state: st.session_state.global_db_filter = 'All'
    if 'global_schema_filter' not in st.session_state: st.session_state.global_schema_filter = 'All'
    if 'global_table_filter' not in st.session_state: st.session_state.global_table_filter = ['All']
    if 'global_scheduling_state_filter' not in st.session_state: st.session_state.global_scheduling_state_filter = ['All']
    if 'global_target_lag' not in st.session_state: st.session_state.global_target_lag = ['All']
    # 'global_is_active_filter' removed from this tab's scope
    if 'display_lag_times_in' not in st.session_state: st.session_state.display_lag_times_in = 'mixed'


    all_options_df = get_all_filter_options_data()

    if all_options_df.empty:
        st.info("No data available to populate filters. Please check the tracking table.", icon="ℹ️")
        return

    st.markdown("---")
    st.subheader("Master Filters")

    # This DataFrame will be progressively filtered as we derive options for cascading widgets.
    filtered_df_for_cascading_options = all_options_df.copy() 

    # --- Step 1: Filter `current_options_for_cascading` based on current selection of parents ---
    # This block ensures `filtered_df_for_cascading_options` is correct for each subsequent child widget.
    # It must process parents in logical order: Domain -> SubDomain -> DB -> Schema
    
    # Domain Name (no parent)
    selected_domain_temp = st.session_state.global_domain_name
    if selected_domain_temp != 'All':
        filtered_df_for_cascading_options = filtered_df_for_cascading_options[filtered_df_for_cascading_options['DOMAIN_NAME'] == selected_domain_temp]

    # Sub Domain Name (depends on Domain)
    selected_sub_domain_temp = st.session_state.global_sub_domain_name
    if selected_sub_domain_temp != 'All':
        filtered_df_for_cascading_options = filtered_df_for_cascading_options[filtered_df_for_cascading_options['SUB_DOMAIN_NAME'] == selected_sub_domain_temp]

    # Database (depends on Sub Domain)
    selected_db_temp = st.session_state.global_db_filter
    if selected_db_temp != 'All':
        filtered_df_for_cascading_options = filtered_df_for_cascading_options[filtered_df_for_cascading_options['DATABASE_NAME'] == selected_db_temp]
    
    # Schema (depends on Database)
    selected_schema_temp = st.session_state.global_schema_filter
    if selected_schema_temp != 'All':
        filtered_df_for_cascading_options = filtered_df_for_cascading_options[filtered_df_for_cascading_options['SCHEMA_NAME'] == selected_schema_temp]
    
    # At this point, `filtered_df_for_cascading_options` holds the correct data
    # to derive options for Schema's children (Table(s)) and beyond.


    # --- Step 2: Render Widgets using the (potentially filtered) options ---
    # Define columns for the 2x4 layout
    filter_cols_row1 = st.columns(4) # Domain, SubDomain, Database, Schema
    filter_cols_row2 = st.columns(4) # Table(s), Scheduling State, Target Lag, Display Lag Times In

    # Render Domain Name
    with filter_cols_row1[0]:
        all_domains = ['All'] + sorted(all_options_df['DOMAIN_NAME'].unique().tolist()) # Options from original data
        # Reset if stored value is no longer valid in options, then render
        if st.session_state.global_domain_name not in all_domains: st.session_state.global_domain_name = 'All'
        st.selectbox("Domain Name:", options=all_domains, key="global_domain_name", on_change=update_session_state_from_widget)

    # Render Sub Domain Name
    with filter_cols_row1[1]:
        # Options depend on current state of selected_domain (filtered_df_for_cascading_options)
        all_sub_domains = ['All'] + sorted(filtered_df_for_cascading_options['SUB_DOMAIN_NAME'].dropna().unique().tolist())
        if st.session_state.global_sub_domain_name not in all_sub_domains: st.session_state.global_sub_domain_name = 'All'
        st.selectbox("Sub Domain Name:", options=all_sub_domains, key="global_sub_domain_name", on_change=update_session_state_from_widget)

    # Render Database
    with filter_cols_row1[2]:
        all_databases = ['All'] + sorted(filtered_df_for_cascading_options['DATABASE_NAME'].unique().tolist())
        if st.session_state.global_db_filter not in all_databases: st.session_state.global_db_filter = 'All'
        st.selectbox("Database:", options=all_databases, key="global_db_filter", on_change=update_session_state_from_widget)

    # Render Schema
    with filter_cols_row1[3]:
        all_schemas = ['All'] + sorted(filtered_df_for_cascading_options['SCHEMA_NAME'].unique().tolist())
        if st.session_state.global_schema_filter not in all_schemas: st.session_state.global_schema_filter = 'All'
        st.selectbox("Schema:", options=all_schemas, key="global_schema_filter", on_change=update_session_state_from_widget)

    # Render Table(s)
    with filter_cols_row2[0]:
        all_tables = ['All'] + sorted(filtered_df_for_cascading_options['TABLE_NAME'].unique().tolist())
        # Multi-select default handling: filter out invalid selections
        valid_current_tables = [t for t in st.session_state.global_table_filter if t in all_tables]
        if not valid_current_tables and 'All' in all_tables: st.session_state.global_table_filter = ['All']
        elif not valid_current_tables: st.session_state.global_table_filter = []
        # Update session_state with the validated list (this is the key for multiselect)
        st.session_state.global_table_filter = valid_current_tables 
        st.multiselect(
            "Table(s):",
            options=all_tables,
            key="global_table_filter", # Reads from/writes to this
            default=st.session_state.global_table_filter, # Must provide default for multiselect
            on_change=update_session_state_from_widget # Update is implicit, but callback triggers rerun
        )

    # Render Scheduling State(s)
    with filter_cols_row2[1]:
        all_scheduling_states = ['All'] + sorted(all_options_df['SCHEDULING_STATE_STATUS'].unique().tolist())
        valid_current_sched_states = [s for s in st.session_state.global_scheduling_state_filter if s in all_scheduling_states]
        if not valid_current_sched_states and 'All' in all_scheduling_states: st.session_state.global_scheduling_state_filter = ['All']
        elif not valid_current_sched_states: st.session_state.global_scheduling_state_filter = []
        st.session_state.global_scheduling_state_filter = valid_current_sched_states # Update state
        st.multiselect(
            "Scheduling State(s):",
            options=all_scheduling_states,
            key="global_scheduling_state_filter",
            default=st.session_state.global_scheduling_state_filter,
            on_change=update_session_state_from_widget
        )

    # Render Target Lag (seconds)
    with cols_row2[2]:
        all_target_lags_formatted = ['All'] + sorted(all_options_df['TARGET_LAG_SEC_FMT'].dropna().unique().tolist())
        valid_current_target_lags = [l for l in st.session_state.global_target_lag if l in all_target_lags_formatted]
        if not valid_current_target_lags and 'All' in all_target_lags_formatted: st.session_state.global_target_lag = ['All']
        elif not valid_current_target_lags: st.session_state.global_target_lag = []
        st.session_state.global_target_lag = valid_current_target_lags # Update state
        st.multiselect(
            "Target Lag (seconds):",
            options=all_target_lags_formatted,
            key="global_target_lag",
            default=st.session_state.global_target_lag,
            on_change=update_session_state_from_widget
        )

    # Render Display Lag Times In (Radio)
    with cols_row2[3]:
        all_time_formats = ["mixed", "seconds", "minutes", "hours", "days"]
        if st.session_state.display_lag_times_in not in all_time_formats: st.session_state.display_lag_times_in = 'mixed'
        st.radio(
            "Display Lag Times In:",
            options=all_time_formats,
            key="display_lag_times_in",
            index=all_time_formats.index(st.session_state.display_lag_times_in), # Radio still needs index
            horizontal=True,
            on_change=update_session_state_from_widget
        )
    
    st.markdown("---")
    st.info("These filters will be automatically applied as a first level of filtering on relevant dashboard tabs.", icon="ℹ️")

# End of tabs/filter_canvas.py
