import streamlit as st
import pandas as pd
from datetime import datetime, timedelta

# --- Dummy Data (Replace with your actual Snowflake fetch logic) ---
@st.cache_data(ttl=3600) # Cache the full table list for an hour
def load_all_tables_from_snowflake():
    dummy_data = {
        'DOMAIN_NAME': ['EFRONT', 'EFRONT', 'EFRONT', 'EFRONT', 'FINANCE', 'FINANCE', 'MKT', 'MKT'] * 100, # Simulate 800 tables
        'SUB_DOMAIN_NAME': ['REF', 'REF', 'MKT', 'MKT', 'ACCT', 'TRX', 'CAMP', 'LEAD'] * 100,
        'DATABASE_NAME': ['EDP_ADC_SDM_DB'] * 800,
        'SCHEMA_NAME': [f'ADC_SDM_EFRONT_{i//200}' for i in range(800)], # Simulate varied schemas
        'TABLE_NAME': [f'T_REF_TABLE_{i:04d}' for i in range(800)],
        'SCHEDULING_STATE_STATUS': ['SUCCESS', 'RUNNING', 'FAILED', 'SUCCESS'] * 200,
        'TARGET_LAG_SEC': [120, 300, 60, 900] * 200,
        'TARGET_LAG_SEC_FMT': [f'{v}s' for v in ([120, 300, 60, 900] * 200)]
    }
    df = pd.DataFrame(dummy_data)
    df['FULL_TABLE_IDENTIFIER'] = df['DATABASE_NAME'] + '.' + df['SCHEMA_NAME'] + '.' + df['TABLE_NAME']
    return df

# --- Configuration & Initialization ---
st.set_page_config(layout="wide", page_title="Snowflake Table Action Selector")

if 'selected_snapshot_tables' not in st.session_state:
    st.session_state.selected_snapshot_tables = set() # Store unique identifiers for global selection
if 'selected_refresh_history_tables' not in st.session_state:
    st.session_state.selected_refresh_history_tables = set()
if 'full_tables_data' not in st.session_state:
    st.session_state.full_tables_data = pd.DataFrame()
# `filtered_tables_for_display` will now be updated on every relevant filter change
# `current_edited_df_state` will always be a copy of `filtered_tables_for_display`
# passed to data_editor, and updated by data_editor's internal state.


st.title("❄️ Snowflake Table Action Selector")
st.info(
    "These filters will be automatically applied as a first level of filtering "
    "on relevant dashboard tabs."
)

st.header("Master Filters")

# --- Load all tables only once ---
if st.session_state.full_tables_data.empty:
    with st.spinner("Loading all table metadata from Snowflake..."):
        st.session_state.full_tables_data = load_all_tables_from_snowflake()

# --- Filter Widgets ---
filter_cols_1 = st.columns(4)
filter_cols_2 = st.columns(4)
filter_cols_3 = st.columns(4) # Assuming this is intended for future filters or layout

with filter_cols_1[0]:
    all_domain_names = ['All'] + sorted(st.session_state.full_tables_data['DOMAIN_NAME'].unique().tolist())
    # Default to 'All'
    selected_domain = st.selectbox("Domain Name:", options=all_domain_names, index=0, key="domain_filter")

with filter_cols_1[1]:
    all_sub_domain_names = ['All'] + sorted(st.session_state.full_tables_data['SUB_DOMAIN_NAME'].unique().tolist())
    # Default to 'All'
    selected_sub_domain = st.selectbox("Sub Domain Name:", options=all_sub_domain_names, index=0, key="subdomain_filter")

with filter_cols_1[2]:
    all_databases = ['All'] + sorted(st.session_state.full_tables_data['DATABASE_NAME'].unique().tolist())
    # Default to 'All'
    selected_database = st.selectbox("Database:", options=all_databases, index=0, key="database_filter")

with filter_cols_1[3]:
    available_schemas = st.session_state.full_tables_data['SCHEMA_NAME'].unique().tolist()
    if selected_database != 'All':
        available_schemas = st.session_state.full_tables_data[st.session_state.full_tables_data['DATABASE_NAME'] == selected_database]['SCHEMA_NAME'].unique().tolist()
    all_schemas_filtered = ['All'] + sorted(available_schemas)
    # Default to 'All'
    selected_schema = st.selectbox("Schema:", options=all_schemas_filtered, index=0, key="schema_filter")


with filter_cols_2[0]:
    current_filtered_table_names_for_widget = st.session_state.full_tables_data['TABLE_NAME'].unique().tolist()
    selected_tables_filter = st.multiselect("Table(s):", options=sorted(current_filtered_table_names_for_widget), default=[], key="tables_filter")

with filter_cols_2[1]:
    all_scheduling_states = ['All'] + sorted(st.session_state.full_tables_data['SCHEDULING_STATE_STATUS'].unique().tolist())
    selected_scheduling_states = st.multiselect("Scheduling State(s):", options=all_scheduling_states, default=['All'], key="scheduling_filter")

with filter_cols_2[2]:
    all_target_lags = ['All'] + sorted(st.session_state.full_tables_data['TARGET_LAG_SEC'].unique().tolist())
    selected_target_lags = st.multiselect("Target Lag (seconds):", options=all_target_lags, default=['All'], key="lag_filter")

with filter_cols_2[3]:
    st.markdown("Display Lag Times In:")
    selected_lag_display_unit = st.radio(
        "Lag Unit",
        options=["mixed", "seconds", "minutes", "hours", "days"],
        index=1,
        label_visibility="collapsed",
        key="lag_unit_radio"
    )

st.markdown("---") # Visual separator

# --- Filter Logic for the Main DataFrame (now automatic on rerun) ---
filtered_df = st.session_state.full_tables_data.copy()

if selected_domain != 'All':
    filtered_df = filtered_df[filtered_df['DOMAIN_NAME'] == selected_domain]
if selected_sub_domain != 'All':
    filtered_df = filtered_df[filtered_df['SUB_DOMAIN_NAME'] == selected_sub_domain]
if selected_database != 'All':
    filtered_df = filtered_df[filtered_df['DATABASE_NAME'] == selected_database]
if selected_schema != 'All':
    filtered_df = filtered_df[filtered_df['SCHEMA_NAME'] == selected_schema]
if selected_tables_filter:
    filtered_df = filtered_df[filtered_df['TABLE_NAME'].isin(selected_tables_filter)]
if 'All' not in selected_scheduling_states:
    filtered_df = filtered_df[filtered_df['SCHEDULING_STATE_STATUS'].isin(selected_scheduling_states)]
if 'All' not in selected_target_lags:
    filtered_df = filtered_df[filtered_df['TARGET_LAG_SEC'].isin(selected_target_lags)]

# Add selection columns, initialized based on global state
filtered_df['SNAPSHOT_SELECT'] = filtered_df['FULL_TABLE_IDENTIFIER'].apply(
    lambda x: x in st.session_state.selected_snapshot_tables
)
filtered_df['REFRESH_HISTORY_SELECT'] = filtered_df['FULL_TABLE_IDENTIFIER'].apply(
    lambda x: x in st.session_state.selected_refresh_history_tables
)

st.session_state.filtered_tables_for_display = filtered_df.reset_index(drop=True)

# Also, re-initialize `current_edited_df_state` from the newly filtered data.
st.session_state.current_edited_df_state = st.session_state.filtered_tables_for_display.copy()


# --- Display and Select Tables (Main Editor) ---
current_filtered_tables_count = len(st.session_state.filtered_tables_for_display)

st.subheader(
    f"Select Tables for Actions ({current_filtered_tables_count} total)"
)

if not st.session_state.filtered_tables_for_display.empty:
    column_configurations = {
        "SNAPSHOT_SELECT": st.column_config.CheckboxColumn("Take Snap", help="Check to take a snapshot", default=False, disabled=False),
        "REFRESH_HISTORY_SELECT": st.column_config.CheckboxColumn("Refresh Hist", help="Check to refresh history", default=False, disabled=False),
        "DOMAIN_NAME": st.column_config.TextColumn("Domain", disabled=True),
        "SUB_DOMAIN_NAME": st.column_config.TextColumn("Sub-Domain", disabled=True),
        "DATABASE_NAME": st.column_config.TextColumn("Database", disabled=True),
        "SCHEMA_NAME": st.column_config.TextColumn("Schema", disabled=True),
        "TABLE_NAME": st.column_config.TextColumn("Table Name", disabled=True),
        "SCHEDULING_STATE_STATUS": st.column_config.TextColumn("Status", disabled=True),
        "TARGET_LAG_SEC_FMT": st.column_config.TextColumn("Lag", disabled=True),
        # FULL_TABLE_IDENTIFIER is configured as hidden but is still part of the DF
        "FULL_TABLE_IDENTIFIER": st.column_config.TextColumn(disabled=True, width="HIDDEN")
    }

    # IMPORTANT CHANGE: Pass the full `st.session_state.current_edited_df_state` to data_editor
    # and use the `column_order` parameter to control visible columns.
    edited_df_from_editor = st.data_editor(
        st.session_state.current_edited_df_state, # Pass the entire DataFrame
        column_config=column_configurations,
        column_order=[ # Explicitly define the order and visibility
            "SNAPSHOT_SELECT", "REFRESH_HISTORY_SELECT", "DOMAIN_NAME", "SUB_DOMAIN_NAME",
            "DATABASE_NAME", "SCHEMA_NAME", "TABLE_NAME", "SCHEDULING_STATE_STATUS", "TARGET_LAG_SEC_FMT"
        ],
        hide_index=True,
        use_container_width=True,
        key="live_table_editor"
    )

    # IMPT: Update st.session_state.current_edited_df_state immediately with changes from the editor
    # This prevents the "unchecking" issue as this DataFrame is the source for data_editor
    st.session_state.current_edited_df_state = edited_df_from_editor.copy()

    # --- "Confirm Selections" Button ---
    st.markdown("---")
    confirm_col1, confirm_col2, confirm_col3 = st.columns([0.6, 0.2, 0.2])
    with confirm_col3:
        if st.button("Confirm Selections", use_container_width=True, key="confirm_selection_btn"):
            for index, row in st.session_state.current_edited_df_state.iterrows():
                # Now, FULL_TABLE_IDENTIFIER is guaranteed to be in `row`
                table_id = row['FULL_TABLE_IDENTIFIER']

                if row['SNAPSHOT_SELECT']:
                    st.session_state.selected_snapshot_tables.add(table_id)
                else:
                    if table_id in st.session_state.selected_snapshot_tables:
                        st.session_state.selected_snapshot_tables.remove(table_id)

                if row['REFRESH_HISTORY_SELECT']:
                    st.session_state.selected_refresh_history_tables.add(table_id)
                else:
                    if table_id in st.session_state.selected_refresh_history_tables:
                        st.session_state.selected_refresh_history_tables.remove(table_id)
            
            st.success("Selections confirmed and updated!")
            st.rerun()

else:
    st.info("No tables to display matching your filters. Adjust filters above.")


# --- DEDICATED "YOUR SELECTIONS" SECTION ---
st.markdown("---")
st.header("Your Current Selections")

# --- Snapshot Selections ---
snapshot_selected_ids = list(st.session_state.selected_snapshot_tables)
if snapshot_selected_ids:
    snapshot_display_df = st.session_state.full_tables_data[
        st.session_state.full_tables_data['FULL_TABLE_IDENTIFIER'].isin(snapshot_selected_ids)
    ]
    st.write(
        f"Tables selected for **Snapshot** "
        f"({len(snapshot_selected_ids)} total):"
    )
    st.dataframe(
        snapshot_display_df[['DATABASE_NAME', 'SCHEMA_NAME', 'TABLE_NAME', 'DOMAIN_NAME', 'SUB_DOMAIN_NAME']].sort_values('TABLE_NAME'),
        hide_index=True,
        use_container_width=True
    )
else:
    st.info("No tables currently selected for Snapshot.")

st.markdown("---") # Separator between selection lists

# --- Refresh History Selections ---
refresh_history_selected_ids = list(st.session_state.selected_refresh_history_tables)
if refresh_history_selected_ids:
    refresh_history_display_df = st.session_state.full_tables_data[
        st.session_state.full_tables_data['FULL_TABLE_IDENTIFIER'].isin(refresh_history_selected_ids)
    ]
    st.write(
        f"Tables selected for **Refresh History** "
        f"({len(refresh_history_selected_ids)} total):"
    )
    st.dataframe(
        refresh_history_display_df[['DATABASE_NAME', 'SCHEMA_NAME', 'TABLE_NAME', 'DOMAIN_NAME', 'SUB_DOMAIN_NAME']].sort_values('TABLE_NAME'),
        hide_index=True,
        use_container_width=True
    )
else:
    st.info("No tables currently selected for Refresh History.")

# --- Action Buttons (referring to the GLOBAL persistent selection state) ---
st.markdown("---")
col_action1, col_action2 = st.columns(2)

with col_action1:
    if st.button(f"Execute Snapshot Action ({len(st.session_state.selected_snapshot_tables)} tables)",
                 disabled=(len(st.session_state.selected_snapshot_tables) == 0)):
        st.success(f"Initiating Snapshot for {len(st.session_state.selected_snapshot_tables)} tables.")
        # Your actual action logic here
        st.session_state.selected_snapshot_tables.clear()
        st.rerun()

with col_action2:
    if st.button(f"Execute Refresh History Action ({len(st.session_state.selected_refresh_history_tables)} tables)",
                 disabled=(len(st.session_state.selected_refresh_history_tables) == 0)):
        st.success(f"Initiating Refresh History for {len(st.session_state.selected_refresh_history_tables)} tables.")
        # Your actual action logic here
        st.session_state.selected_refresh_history_tables.clear()
        st.rerun()

st.markdown("---")
st.markdown("Developed by T3 Chat for Data Engineers 🤖")
