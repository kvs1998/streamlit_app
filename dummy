# tabs/dt_health_tab.py
import streamlit as st
import pandas as pd
import numpy as np

# --- Helper function to convert seconds to a more readable format ---
def format_seconds_to_readable(seconds_series, format_type):
    if format_type == "seconds":
        return seconds_series.round(1).astype(str) + "s"
    elif format_type == "minutes":
        return (seconds_series / 60).round(1).astype(str) + "m"
    elif format_type == "hours":
        return (seconds_series / 3600).round(1).astype(str) + "h"
    elif format_type == "days":
        return (seconds_series / 86400).round(1).astype(str) + "d"
    elif format_type == "mixed":
        def mix_format(s):
            if pd.isna(s) or s is None: return "N/A"
            s = float(s)
            if s == 0: return "0s"

            days = int(s // 86400)
            hours = int((s % 86400) // 3600)
            minutes = int((s % 3600) // 60)
            seconds = s % 60
            
            parts = []
            if days > 0: parts.append(f"{days}d")
            if hours > 0: parts.append(f"{hours}h")
            if minutes > 0: parts.append(f"{minutes}m")
            if seconds > 0 and (not parts or seconds >= 1):
                parts.append(f"{seconds:.1f}s")
            
            return " ".join(parts) if parts else "0s"
        return seconds_series.apply(mix_format)
    return seconds_series


# --- Define Global Colors for Row Styling ---
BG_COLOR_GOOD = '#ccffcc' # Light Green
BG_COLOR_WARNING = '#ffe0b3' # Light Orange
BG_COLOR_CRITICAL = '#ffcccc' # Light Red
BG_COLOR_INFO = '#cce5ff' # Light Blue for suspended
BG_COLOR_NONE = '#ffffff' # Explicit white for 'None' option or NaN values


# --- FIX: Moved apply_row_style to GLOBAL SCOPE ---
# Helper function for ROW-WISE conditional formatting
def apply_row_style(row, color_by_option, thresholds, original_df_metadata, time_format_option):
    """
    Applies background color to the entire row based on the selected metric and its thresholds.
    - row: A row from the DataFrame being styled, with display labels.
    - color_by_option, thresholds, original_df_metadata, time_format_option: Passed as args from lambda.
    """
    # Lookup the corresponding row from the original metadata_df using the 'Dynamic Table' column (QUALIFIED_NAME).
    original_qualified_name = row.get('Dynamic Table')
    
    row_original_data = pd.Series(dtype='object')
    if original_qualified_name and original_qualified_name in original_df_metadata['QUALIFIED_NAME'].values:
        row_original_data = original_df_metadata[original_df_metadata['QUALIFIED_NAME'] == original_qualified_name].iloc[0]

    style_str = BG_COLOR_NONE

    if row_original_data.empty:
        pass 
    elif color_by_option == 'Status':
        status = row_original_data.get('SCHEDULING_STATE_STATUS')
        last_refresh_state = row_original_data.get('LAST_COMPLETED_REFRESH_STATE')

        if status == 'SUSPENDED':
            style_str = f'background-color: {BG_COLOR_INFO}'
        elif last_refresh_state == 'FAILED':
            style_str = f'background-color: {BG_COLOR_CRITICAL}'
        elif last_refresh_state in ['UPSTREAM_FAILED', 'CANCELLED', 'WARNING']:
            style_str = f'background-color: {BG_COLOR_WARNING}'
        elif status == 'RUNNING' and last_refresh_state == 'SUCCEEDED':
            style_str = f'background-color: {BG_COLOR_GOOD}'
        else:
            style_str = f'background-color: {BG_COLOR_GOOD}'

    elif color_by_option == 'Mean Lag':
        lag = row_original_data.get('MEAN_LAG_SEC')
        if pd.isna(lag):
            style_str = f'background-color: {BG_COLOR_NONE}'
        elif lag >= thresholds['mean_lag']['critical']:
            style_str = f'background-color: {BG_COLOR_CRITICAL}'
        elif lag >= thresholds['mean_lag']['warning']:
            style_str = f'background-color: {BG_COLOR_WARNING}'
        else:
            style_str = f'background-color: {BG_COLOR_GOOD}'

    elif color_by_option == 'Max Lag':
        lag = row_original_data.get('MAXIMUM_LAG_SEC')
        if pd.isna(lag):
            style_str = f'background-color: {BG_COLOR_NONE}'
        elif lag >= thresholds['max_lag']['critical']:
            style_str = f'background-color: {BG_COLOR_CRITICAL}'
        elif lag >= thresholds['max_lag']['warning']:
            style_str = f'background-color: {BG_COLOR_WARNING}'
        else:
            style_str = f'background-color: {BG_COLOR_GOOD}'

    elif color_by_option == 'Time Above Target Lag':
        time_above = row_original_data.get('TIME_ABOVE_TARGET_LAG_SEC')
        if pd.isna(time_above):
            style_str = f'background-color: {BG_COLOR_NONE}'
        elif time_above > thresholds['time_above']['critical']:
            style_str = f'background-color: {BG_COLOR_CRITICAL}'
        elif time_above > thresholds['time_above']['warning']:
            style_str = f'background-color: {BG_COLOR_WARNING}'
        else:
            style_str = f'background-color: {BG_COLOR_GOOD}'

    elif color_by_option == 'Lag Ratio':
        ratio = row_original_data.get('TIME_WITHIN_TARGET_LAG_RATIO')
        if pd.isna(ratio):
            style_str = f'background-color: {BG_COLOR_NONE}'
        elif ratio < thresholds['lag_ratio']['critical']:
            style_str = f'background-color: {BG_COLOR_CRITICAL}'
        elif ratio < thresholds['lag_ratio']['warning']:
            style_str = f'background-color: {BG_COLOR_WARNING}'
        else:
            style_str = f'background-color: {BG_COLOR_GOOD}'
    
    return pd.Series(style_str, index=row.index)


def render_dt_health_tab(metadata_df: pd.DataFrame):
    st.header("Dynamic Table Health & Current Status")
    st.write("Analyze the current operational state and aggregate lag metrics of your dynamic tables.")

    if metadata_df.empty:
        st.info("No metadata available for DT HEALTH tab. Check data source or collection.", icon="ℹ️")
        return

    # Ensure all required numeric columns are present and numeric
    required_numeric_cols = ['MEAN_LAG_SEC', 'MAXIMUM_LAG_SEC', 'TIME_ABOVE_TARGET_LAG_SEC', 'TIME_WITHIN_TARGET_LAG_RATIO', 'TARGET_LAG_SEC']
    for col in required_numeric_cols:
        if col not in metadata_df.columns:
            metadata_df[col] = np.nan
        metadata_df[col] = pd.to_numeric(metadata_df[col], errors='coerce')


    # --- Direct use of metadata_df as the filtered_metadata_df ---
    filtered_metadata_df = metadata_df.copy() 

    if filtered_metadata_df.empty:
        st.info("No Dynamic Table data available. Please adjust your filters or check data source.", icon="ℹ️")
        return


    # --- Filters for DT Health Tab ---
    st.markdown("---")
    st.subheader("Apply Filters for DT Health")

    filter_cols_dt_health_row1 = st.columns([1, 1, 1, 1])

    with filter_cols_dt_health_row1[0]:
        all_databases_dt_health = ['All'] + sorted(filtered_metadata_df['DATABASE_NAME'].unique().tolist())
        selected_database_dt_health = st.selectbox(
            "Database:", options=all_databases_dt_health, key="new_db_filter_dt_health"
        )
    with filter_cols_dt_health_row1[1]:
        temp_df_for_schema_options = filtered_metadata_df.copy()
        if selected_database_dt_health != 'All':
            temp_df_for_schema_options = temp_df_for_schema_options[temp_df_for_schema_options['DATABASE_NAME'] == selected_database_dt_health].copy()

        if not temp_df_for_schema_options.empty:
            schemas_in_db_dt_health = ['All'] + sorted(temp_df_for_schema_options['SCHEMA_NAME'].unique().tolist())
        else:
            schemas_in_db_dt_health = ['All']
            st.info("No schemas found for selected Database.", icon="ℹ️")

        selected_schema_dt_health = st.selectbox(
            "Schema:", options=schemas_in_db_dt_health, key="new_schema_filter_dt_health"
        )
    
    df_for_table_options = filtered_metadata_df.copy()
    if selected_database_dt_health != 'All':
        df_for_table_options = df_for_table_options[df_for_table_options['DATABASE_NAME'] == selected_database_dt_health].copy()
    if selected_schema_dt_health != 'All':
        df_for_table_options = df_for_table_options[df_for_table_options['SCHEMA_NAME'] == selected_schema_dt_health].copy()


    with filter_cols_dt_health_row1[2]:
        if not df_for_table_options.empty:
            all_tables_dt_health_options = ['All'] + sorted(df_for_table_options['TABLE_NAME'].unique().tolist())
            default_tables_dt_health_selected = ['All']
        else:
            all_tables_dt_health_options = ['All']
            default_tables_dt_health_selected = ['All']
            st.info("No tables found for selected DB/Schema.", icon="ℹ️")
        selected_table_dt_health = st.multiselect(
            "Table(s):", options=all_tables_dt_health_options, default=default_tables_dt_health_selected, key="new_table_filter_dt_health"
        )
    with filter_cols_dt_health_row1[3]:
        all_scheduling_states = ['All'] + sorted(filtered_metadata_df['SCHEDULING_STATE_STATUS'].unique().tolist())
        selected_scheduling_state = st.multiselect(
            "Scheduling State(s):", options=all_scheduling_states, default=['All'], key="new_scheduling_state_filter_dt_health"
        )
    
    filter_cols_dt_health_row2 = st.columns([1])
    with filter_cols_dt_health_row2[0]:
        time_format_option = st.radio(
            "Display Lag Times In:", 
            options=["mixed", "seconds", "minutes", "hours", "days"], 
            index=0,
            horizontal=True,
            key="new_time_format_dt_health"
        )
    
    st.markdown("---")


    # --- Apply Filters to Main DataFrame (re-filter based on user selections) ---
    final_filtered_metadata_df = filtered_metadata_df.copy() 

    if selected_database_dt_health != 'All':
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['DATABASE_NAME'] == selected_database_dt_health].copy()
    if selected_schema_dt_health != 'All':
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['SCHEMA_NAME'] == selected_schema_dt_health].copy()
    if selected_table_dt_health and 'All' not in selected_table_dt_health:
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['TABLE_NAME'].isin(selected_table_dt_health)].copy()
    elif not selected_table_dt_health:
        st.warning("No table(s) selected. Display will be empty.", icon="⚠️")
        final_filtered_metadata_df = pd.DataFrame()

    if selected_scheduling_state and 'All' not in selected_scheduling_state:
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['SCHEDULING_STATE_STATUS'].isin(selected_scheduling_state)].copy()
    elif not selected_scheduling_state:
        st.warning("No scheduling state(s) selected. Display will be empty.", icon="⚠️")
        final_filtered_metadata_df = pd.DataFrame()

    if final_filtered_metadata_df.empty:
        st.info("No data available based on current filter selections. Please adjust your filters.", icon="ℹ️")
        return


    # --- KPI Section ---
    st.subheader("Dynamic Table Health Summary")
    
    total_dt_monitored = final_filtered_metadata_df['QUALIFIED_NAME'].nunique()
    running_dt_count = final_filtered_metadata_df[
        (final_filtered_metadata_df['SCHEDULING_STATE_STATUS'] == 'RUNNING') & 
        (final_filtered_metadata_df['LAST_COMPLETED_REFRESH_STATE'] == 'SUCCEEDED')
    ]['QUALIFIED_NAME'].nunique()
    suspended_dt_count = final_filtered_metadata_df[
        final_filtered_metadata_df['SCHEDULING_STATE_STATUS'] == 'SUSPENDED'
    ]['QUALIFIED_NAME'].nunique()
    running_but_failed_dt_count = final_filtered_metadata_df[
        (final_filtered_metadata_df['SCHEDULING_STATE_STATUS'] == 'RUNNING') & 
        (final_filtered_metadata_df['LAST_COMPLETED_REFRESH_STATE'].isin(['FAILED', 'UPSTREAM_FAILED', 'CANCELLED']))
    ]['QUALIFIED_NAME'].nunique()
    executing_refresh_dt_count = final_filtered_metadata_df[final_filtered_metadata_df['EXECUTING_REFRESH_QUERY_ID'].notna()]['QUALIFIED_NAME'].nunique()
    
    avg_mean_lag = final_filtered_metadata_df['MEAN_LAG_SEC'].mean()
    max_lag = final_filtered_metadata_df['MAXIMUM_LAG_SEC'].max()

    avg_mean_lag_fmt = format_seconds_to_readable(pd.Series([avg_mean_lag]), time_format_option).iloc[0] if not pd.isna(avg_mean_lag) else "N/A"
    max_lag_fmt = format_seconds_to_readable(pd.Series([max_lag]), time_format_option).iloc[0] if not pd.isna(max_lag) else "N/A"

    kpi_cols = st.columns(3)
    with kpi_cols[0]:
        st.metric("Total Monitored", total_dt_monitored)
        st.metric("Running (Healthy)", running_dt_count, delta=executing_refresh_dt_count, delta_color="normal")
    with kpi_cols[1]:
        st.metric("Suspended", suspended_dt_count, delta_color="inverse")
        st.metric("Running (Actively Failing)", running_but_failed_dt_count, delta_color="inverse")
    with kpi_cols[2]:
        st.metric("Avg Mean Lag", avg_mean_lag_fmt)
        st.metric("Max Lag", max_lag_fmt)

    st.divider()

    # --- Detailed Dynamic Table Current Status Table ---
    st.subheader("Detailed Dynamic Table Status")
    
    # Radio buttons for conditional formatting
    color_by_option = st.radio(
        "Color Table By:",
        ('None', 'Status', 'Mean Lag', 'Max Lag', 'Time Above Target Lag', 'Lag Ratio'),
        index=0,
        horizontal=True,
        key="new_color_by_dt_health_table"
    )

    # --- Dynamic Severity Legend Section ---
    st.markdown("""
        <style>
        .legend-item {
            display: inline-block;
            margin-right: 15px;
            font-size: 14px;
        }
        .color-box {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            display: inline-block;
            vertical-align: middle;
            margin-right: 5px;
            border: 1px solid #ccc; /* Add a subtle border for visibility */
        }
        </style>
        """, unsafe_allow_html=True)
    
    # Generate dynamic range labels for numeric options
    legend_content = ""
    # Define thresholds for legend generation. This ensures consistency with apply_row_style.
    legend_thresholds = {
        'mean_lag': {'ok': 300, 'warning': 1800, 'critical': 3600}, # seconds
        'max_lag': {'ok': 600, 'warning': 3600, 'critical': 7200}, # seconds
        'time_above': {'ok': 0, 'warning': 300, 'critical': 1800}, # seconds
        'lag_ratio': {'ok': 0.90, 'warning': 0.70, 'critical': 0.01} # 0-1 ratio
    }
    
    if color_by_option == 'None':
        legend_content = "" # No legend if no coloring
    elif color_by_option == 'Status':
        legend_content = f"""
            <div class='legend-item'><span class='color-box' style='background-color: {BG_COLOR_GOOD};'></span>Succeeded / Healthy</div>
            <div class='legend-item'><span class='color-box' style='background-color: {BG_COLOR_INFO};'></span>Suspended</div>
            <div class='legend-item'><span class='color-box' style='background-color: {BG_COLOR_WARNING};'></span>Warning / Running (Failing)</div>
            <div class='legend-item'><span class='color-box' style='background-color: {BG_COLOR_CRITICAL};'></span>Failed</div>
        """
    else: # Numeric options: Mean Lag, Max Lag, Time Above Target Lag, Lag Ratio
        col_key = { # Map radio button label to internal threshold key
            'Mean Lag': 'mean_lag',
            'Max Lag': 'max_lag',
            'Time Above Target Lag': 'time_above',
            'Lag Ratio': 'lag_ratio'
        }.get(color_by_option)

        if col_key:
            threshold_set = legend_thresholds[col_key] # Use the re-defined thresholds
            
            # Helper for formatting values in legend
            def format_legend_value_for_display(val_raw, col_type, t_format_option):
                if col_type == 'Lag Ratio':
                    return f"{round(val_raw * 100, 1)}%"
                else: # Lag in seconds, use main format_seconds_to_readable
                    return format_seconds_to_readable(pd.Series([val_raw]), t_format_option).iloc[0]
            
            critical_val_fmt = format_legend_value_for_display(threshold_set['critical'], color_by_option, time_format_option)
            warning_val_fmt = format_legend_value_for_display(threshold_set['warning'], color_by_option, time_format_option)
            ok_val_fmt = format_legend_value_for_display(threshold_set['ok'], color_by_option, time_format_option)

            if color_by_option in ['Mean Lag', 'Max Lag', 'Time Above Target Lag']:
                # Higher values are worse (Red > Yellow > Green)
                legend_content = f"""
                    <div class='legend-item'><span class='color-box' style='background-color: {BG_COLOR_CRITICAL};'></span>Critical (> {critical_val_fmt})</div>
                    <div class='legend-item'><span class='color-box' style='background-color: {BG_COLOR_WARNING};'></span>Warning (> {warning_val_fmt})</div>
                    <div class='legend-item'><span class='color-box' style='background-color: {BG_COLOR_GOOD};'></span>Good (<= {ok_val_fmt})</div>
                """
            else: # Lag Ratio: Lower values are worse (Red < Yellow < Green)
                legend_content = f"""
                    <div classt='legend-item'><span class='color-box' style='background-color: {BG_COLOR_CRITICAL};'></span>Critical (< {critical_val_fmt})</div>
                    <div class='legend-item'><span class='color-box' style='background-color: {BG_COLOR_WARNING};'></span>Warning (< {warning_val_fmt})</div>
                    <div class='legend-item'><span class='color-box' style='background-color: {BG_COLOR_GOOD};'></span>Good (>= {ok_val_fmt})</div>
                """
        
    if legend_content:
        st.markdown(
            f"""
            <div style='display: flex; align-items: center; margin-bottom: 10px; flex-wrap: wrap;'>
                <span style='font-weight: bold; font-size: 16px; margin-right: 10px;'>Severity:</span>
                {legend_content}
            </div>
            """, unsafe_allow_html=True
        )
    # --- End Dynamic Severity Legend Section ---

    st.write("Detailed metadata and lag metrics for each dynamic table based on latest snapshot.")

    if final_filtered_metadata_df.empty:
        st.info("No detailed dynamic table status to display based on current filters.", icon="ℹ️")
        return

    # Use a copy for display formatting
    df_for_display = final_filtered_metadata_df.copy()
    
    # Define thresholds for coloring based on typical values. Pass this 'thresholds' dict to apply_row_style.
    thresholds_for_styling = {
        'mean_lag': {'ok': 300, 'warning': 1800, 'critical': 3600}, # 5min, 30min, 1hr in seconds
        'max_lag': {'ok': 600, 'warning': 3600, 'critical': 7200}, # 10min, 1hr, 2hr in seconds
        'time_above': {'ok': 0, 'warning': 300, 'critical': 1800}, # 0, 5min, 30min in seconds
        'lag_ratio': {'ok': 0.90, 'warning': 0.70, 'critical': 0.01} # 90%, 70%, 1%
    }

    # Apply formatting for display to new columns
    df_for_display['TARGET_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['TARGET_LAG_SEC'], time_format_option)
    df_for_display['MEAN_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['MEAN_LAG_SEC'], time_format_option)
    df_for_display['MAXIMUM_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['MAXIMUM_LAG_SEC'], time_format_option)
    df_for_display['TIME_ABOVE_TARGET_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['TIME_ABOVE_TARGET_LAG_SEC'], time_format_option)
    
    # FIX: Handle NaN in TIME_WITHIN_TARGET_LAG_RATIO to be 0% for display
    df_for_display['TIME_WITHIN_TARGET_LAG_RATIO_FMT'] = final_filtered_metadata_df['TIME_WITHIN_TARGET_LAG_RATIO'].fillna(0).apply(lambda x: f"{round(x * 100, 1)}%")


    # Define display columns and their labels
    dt_health_display_columns_order = [
        'QUALIFIED_NAME',
        'SCHEDULING_STATE_STATUS', 'SCHEDULING_STATE_REASON_MESSAGE', 
        'TARGET_LAG_SEC_FMT', 'MEAN_LAG_SEC_FMT', 'MAXIMUM_LAG_SEC_FMT',
        'TIME_ABOVE_TARGET_LAG_SEC_FMT', 'TIME_WITHIN_TARGET_LAG_RATIO_FMT', 
        'LATEST_DATA_TIMESTAMP', 'LAST_COMPLETED_REFRESH_STATE', 'EXECUTING_REFRESH_QUERY_ID',
        'COLLECTION_TIMESTAMP'
    ]
    
    dt_health_display_labels = {
        'QUALIFIED_NAME': 'Dynamic Table',
        'SCHEDULING_STATE_STATUS': 'Status',
        'SCHEDULING_STATE_REASON_MESSAGE': 'Reason',
        'TARGET_LAG_SEC_FMT': 'Target Lag',
        'MEAN_LAG_SEC_FMT': 'Mean Lag',
        'MAXIMUM_LAG_SEC_FMT': 'Max Lag',
        'TIME_ABOVE_TARGET_LAG_SEC_FMT': 'Time Above Lag',
        'TIME_WITHIN_TARGET_LAG_RATIO_FMT': 'Lag Ratio (%)',
        'LATEST_DATA_TIMESTAMP': 'Latest Data Time',
        'LAST_COMPLETED_REFRESH_STATE': 'Last Refresh Status',
        'EXECUTING_REFRESH_QUERY_ID': 'Executing Query ID',
        'COLLECTION_TIMESTAMP': 'Snapshot Time'
    }

    # Select and rename columns for the display DataFrame
    df_for_display = df_for_display[[col for col in dt_health_display_columns_order if col in df_for_display.columns]].rename(columns=dt_health_display_labels)


    # --- Apply Sorting ---
    final_df_for_display_sorted = df_for_display.copy()

    # Determine sorting criteria
    original_sort_column_map = {
        'Status': 'SCHEDULING_STATE_STATUS',
        'Mean Lag': 'MEAN_LAG_SEC',
        'Max Lag': 'MAXIMUM_LAG_SEC',
        'Time Above Target Lag': 'TIME_ABOVE_TARGET_LAG_SEC',
        'Lag Ratio': 'TIME_WITHIN_TARGET_LAG_RATIO'
    }
    
    sort_column_original_name = original_sort_column_map.get(color_by_option)

    if sort_column_original_name:
        if sort_column_original_name != 'SCHEDULING_STATE_STATUS': # Sort numeric columns directly
            ascending = True if color_by_option == 'Lag Ratio' else False
            
            sort_order_indices = final_filtered_metadata_df.sort_values(
                by=sort_column_original_name, ascending=ascending, na_position='last'
            ).index
            final_df_for_display_sorted = final_df_for_display_sorted.loc[sort_order_indices].reset_index(drop=True)
            
        else: # Custom sort for 'Status' column (SCHEDULING_STATE_STATUS) based on severity
            status_severity_order = {
                'SUSPENDED': 0, # Highest severity
                'FAILED': 1,
                'UPSTREAM_FAILED': 2,
                'CANCELLED': 3,
                'WARNING': 4,
                'RUNNING': 5,
                'SUCCEEDED': 6,
                'UNKNOWN': 7
            }
            # Add temporary sort keys on the original data (which aligns by index)
            temp_status_keys = final_filtered_metadata_df['SCHEDULING_STATE_STATUS'].map(status_severity_order).fillna(999)
            temp_last_refresh_keys = final_filtered_metadata_df['LAST_COMPLETED_REFRESH_STATE'].map({
                'FAILED': 0, 'UPSTREAM_FAILED': 1, 'CANCELLED': 2, 'WARNING': 3, 'SUCCEEDED': 4, 'UNKNOWN': 5
            }).fillna(999)

            temp_sort_df = pd.DataFrame({
                'Status_Key': temp_status_keys,
                'Last_Refresh_Key': temp_last_refresh_keys
            }, index=final_filtered_metadata_df.index)

            sort_order_indices = temp_sort_df.sort_values(
                by=['Status_Key', 'Last_Refresh_Key'], ascending=[True, True]
            ).index
            final_df_for_display_sorted = final_df_for_display_sorted.loc[sort_order_indices].reset_index(drop=True)


    # --- Apply Styling (row-wise background color) ---
    if color_by_option != 'None':
        # FIX: Corrected lambda to pass the necessary arguments in the correct order.
        # This lambda will correctly pass:
        #   - row_display: the row from final_df_for_display_sorted (with display labels)
        #   - color_by_option: from the radio button
        #   - thresholds_for_styling: the defined thresholds
        #   - final_filtered_metadata_df: the original full DataFrame (captured in the lambda's closure)
        #   - time_format_option: for consistency in formatting (captured in lambda's closure)
        styled_df = final_df_for_display_sorted.style.apply(
            lambda row_display: apply_row_style(
                row_display,
                final_filtered_metadata_df, # Pass the original DF for lookup inside apply_row_style
                color_by_option,
                thresholds_for_styling,
                time_format_option
            ), 
            axis=1 # Apply row-wise
        )
        st.dataframe(
            styled_df,
            use_container_width=True
        )
    else: # Render without styling
        st.dataframe(
            final_df_for_display_sorted, # Display the sorted df without styling
            use_container_width=True
        )
