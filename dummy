-- Inside SP_DRIVE_ALL_DT_COLLECTION:

    -- --- STEP: Consolidate ASYNC Job Statuses from TRACKING STAGING TABLE ---
    -- ...
    DECLARE
        c_tracking_results CURSOR FOR
            SELECT QUALIFIED_NAME, JOB_TYPE, STATUS, MESSAGE
            FROM IDENTIFIER(:lv_tracking_update_staging_table_fqdn)
            WHERE DRIVER_RUN_UUID = :lv_driver_run_uuid
            ORDER BY QUALIFIED_NAME, JOB_TYPE;
        
        job_status VARCHAR;
        job_message VARCHAR;
        table_job_details_map OBJECT DEFAULT OBJECT_CONSTRUCT();
        table_overall_status VARCHAR;
    BEGIN
        FOR tracking_record IN c_tracking_results DO
            job_status := tracking_record.STATUS;
            job_message := tracking_record.MESSAGE;

            -- NEW LOGIC: Only mark lv_any_async_job_reported_failure if status is a true 'FAILED'
            IF (job_status LIKE 'FAILED%') THEN -- Check if status starts with 'FAILED'
                lv_any_async_job_reported_failure := TRUE;
                lv_message := lv_message || '  JOB STATUS: ' || tracking_record.QUALIFIED_NAME || ' (' || tracking_record.JOB_TYPE || ') -> FAILED: ' || job_message || '\n';
            ELSE
                lv_message := lv_message || '  JOB STATUS: ' || tracking_record.QUALIFIED_NAME || ' (' || tracking_record.JOB_TYPE || ') -> ' || job_status || ': ' || job_message || '\n';
            END IF;

            -- Build the nested job_details object for each qualified_name (for return JSON)
            DECLARE
                local_table_job_details_map OBJECT := :table_job_details_map;
                current_job_details OBJECT DEFAULT GET(local_table_job_details_map, tracking_record.QUALIFIED_NAME);
            BEGIN
                IF (current_job_details IS NULL) THEN
                    current_job_details := OBJECT_CONSTRUCT();
                END IF;

                current_job_details := OBJECT_INSERT(
                    current_job_details,
                    tracking_record.JOB_TYPE,
                    CASE WHEN job_status = 'SUCCESS' THEN OBJECT_CONSTRUCT('status', job_status)
                         WHEN job_status = 'SUCCESS_NO_RECORDS' THEN OBJECT_CONSTRUCT('status', job_status) -- Treat as success
                         ELSE OBJECT_CONSTRUCT('status', job_status, 'message', job_message)
                    END,
                    TRUE
                );

                table_job_details_map := OBJECT_INSERT(local_table_job_details_map, tracking_record.QUALIFIED_NAME, current_job_details, TRUE);
            END;
        END FOR;

        -- Now, iterate through the consolidated map to build the final lv_job_audit_details array
        FOR qualified_name_key IN (SELECT KEY FROM TABLE(FLATTEN(input => :table_job_details_map))) DO
            DECLARE
                q_name VARCHAR := qualified_name_key.KEY;
                job_details OBJECT := GET(:table_job_details_map, q_name);
                
                refresh_history_status VARCHAR := GET(GET(job_details, 'REFRESH_HISTORY'), 'status');
                metadata_snapshot_status VARCHAR := GET(GET(job_details, 'METADATA_SNAPSHOT'), 'status');
            BEGIN
                -- Determine overall_table_status for each table
                IF (refresh_history_status LIKE 'FAILED%' OR metadata_snapshot_status LIKE 'FAILED%') THEN -- Check if ANY job type failed
                    table_overall_status := 'FAILED';
                ELSIF (
                    (refresh_history_status IN ('SUCCESS', 'SUCCESS_NO_RECORDS') OR refresh_history_status IS NULL) AND
                    (metadata_snapshot_status IN ('SUCCESS', 'SUCCESS_NO_RECORDS') OR metadata_snapshot_status IS NULL)
                ) THEN
                    -- Check for full success vs. partial success
                    IF ( (refresh_history_status = 'SUCCESS' AND metadata_snapshot_status = 'SUCCESS') OR
                         (refresh_history_status = 'SUCCESS' AND metadata_snapshot_status = 'SUCCESS_NO_RECORDS') OR
                         (refresh_history_status = 'SUCCESS_NO_RECORDS' AND metadata_snapshot_status = 'SUCCESS') OR
                         (refresh_history_status = 'SUCCESS_NO_RECORDS' AND metadata_snapshot_status = 'SUCCESS_NO_RECORDS')
                       ) THEN
                        table_overall_status := 'SUCCESS';
                    ELSE -- One is SUCCESS/SUCCESS_NO_RECORDS, the other is NULL or different
                        table_overall_status := 'PARTIAL_SUCCESS';
                    END IF;
                ELSE
                    table_overall_status := 'MIXED_STATUS'; -- Should catch unexpected states
                END IF;

                lv_job_audit_details := ARRAY_APPEND(:lv_job_audit_details, OBJECT_CONSTRUCT(
                    'qualified_name', q_name,
                    'job_details', job_details,
                    'overall_table_status', table_overall_status
                ));
            END;
        END FOR;

    END;
    lv_message := lv_message || 'ASYNC job status consolidation complete. Audit details prepared.\n';


    IF (lv_any_async_job_reported_failure) THEN
        lv_message := lv_message || 'FAILURE DETECTED: One or more ASYNC jobs reported non-SUCCESS status. Skipping merges to main tables and rolling back.\n';
    ELSE
        lv_message := lv_message || 'All ASYNC jobs reported SUCCESS (including those with no records). Proceeding with merges.\n';
    END IF;

    -- ... (rest of the code for merge and final summary) ...

    -- Final counts in Step 7 also need to be adjusted:
    SELECT COUNT(*) INTO lv_overall_success_count
    FROM IDENTIFIER(:lv_tracking_update_staging_table_fqdn)
    WHERE DRIVER_RUN_UUID = :lv_driver_run_uuid
      AND STATUS IN ('SUCCESS', 'SUCCESS_NO_RECORDS'); -- Include 'SUCCESS_NO_RECORDS' as success

    SELECT COUNT(*) INTO lv_overall_fail_count
    FROM IDENTIFIER(:lv_tracking_update_staging_table_fqdn)
    WHERE DRIVER_RUN_UUID = :lv_driver_run_uuid
      AND STATUS LIKE 'FAILED%'; -- Only count statuses starting with 'FAILED' as failures
