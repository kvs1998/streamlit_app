# tabs/dt_health_tab.py
import streamlit as st
import pandas as pd
import plotly.express as px
import numpy as np
from datetime import datetime, time, date


# Helper function to convert seconds to a more readable format
def format_seconds_to_readable(seconds_series, format_type):
    if format_type == "seconds":
        return seconds_series.round(1).astype(str) + "s"
    elif format_type == "minutes":
        return (seconds_series / 60).round(1).astype(str) + "m"
    elif format_type == "hours":
        return (seconds_series / 3600).round(1).astype(str) + "h"
    elif format_type == "days":
        return (seconds_series / 86400).round(1).astype(str) + "d"
    elif format_type == "mixed":
        def mix_format(s):
            if pd.isna(s) or s is None: return "N/A"
            s = float(s)
            if s == 0: return "0s"

            days = int(s // 86400)
            hours = int((s % 86400) // 3600)
            minutes = int((s % 3600) // 60)
            seconds = s % 60
            
            parts = []
            if days > 0: parts.append(f"{days}d")
            if hours > 0: parts.append(f"{hours}h")
            if minutes > 0: parts.append(f"{minutes}m")
            if seconds > 0 and (not parts or seconds >= 1):
                parts.append(f"{seconds:.1f}s")
            
            return " ".join(parts) if parts else "0s"
        return seconds_series.apply(mix_format)

# New helper function for conditional formatting styles (corrected, simplified)
def color_table_row(row, color_by_option, mean_lag_thresholds, max_lag_thresholds, time_above_thresholds, lag_ratio_thresholds):
    """Applies conditional formatting to a row based on selected metric."""
    styles = [''] # Default is no color, to avoid unwanted overrides

    if color_by_option == 'Status':
        status = row.get('SCHEDULING_STATE_STATUS') # Use .get() to prevent KeyErrors
        last_refresh_state = row.get('LAST_COMPLETED_REFRESH_STATE')
        if status == 'SUSPENDED':
            styles.append('background-color: #ffcccc') # Light Red for suspended
        elif status == 'RUNNING' and (last_refresh_state == 'FAILED' or last_refresh_state == 'UPSTREAM_FAILED' or last_refresh_state == 'CANCELLED'):
            styles.append('background-color: #ffe0b3') # Light Orange for running but failing/cancelled
        elif status == 'RUNNING' and last_refresh_state == 'SUCCEEDED':
            styles.append('background-color: #ccffcc') # Light Green for healthy running

    elif color_by_option == 'Mean Lag':
        lag = row.get('MEAN_LAG_SEC')
        if pd.notna(lag) and lag > mean_lag_thresholds['critical']: # Must validate that the column and value exist
            styles.append('background-color: #ffcccc') # Red
        elif pd.notna(lag) and lag > mean_lag_thresholds['warning']:
            styles.append('background-color: #ffe0b3') # Orange
        elif pd.notna(lag) and lag <= mean_lag_thresholds['ok']:
            styles.append('background-color: #ccffcc') # Green (for very low lag)

    elif color_by_option == 'Max Lag':
        lag = row.get('MAXIMUM_LAG_SEC')
        if pd.notna(lag):
            if lag > max_lag_thresholds['critical']:
                styles.append('background-color: #ffcccc')
            elif lag > max_lag_thresholds['warning']:
                styles.append('background-color: #ffe0b3')
            elif lag <= max_lag_thresholds['ok']:
                styles.append('background-color: #ccffcc')

    elif color_by_option == 'Time Above Target Lag':
        time_above = row.get('TIME_ABOVE_TARGET_LAG_SEC')
        if pd.notna(time_above):
            if time_above > time_above_thresholds['critical']: # Significant time above target
                styles.append('background-color: #ffcccc')
            elif time_above > time_above_thresholds['warning']: # Some time above target
                styles.append('background-color: #ffe0b3')
            elif time_above <= time_above_thresholds['ok']: # Very little/no time above target
                styles.append('background-color: #ccffcc')

    elif color_by_option == 'Lag Ratio':
        ratio = row.get('TIME_WITHIN_TARGET_LAG_RATIO')
        if pd.notna(ratio):
            if ratio < lag_ratio_thresholds['critical']: # Less than 70% compliant
                styles.append('background-color: #ffcccc')
            elif ratio < lag_ratio_thresholds['warning']: # Between 70% and 90% compliant
                styles.append('background-color: #ffe0b3')
            elif ratio >= lag_ratio_thresholds['ok']: # 90% or more compliant
                styles.append('background-color: #ccffcc')
    
    return '; '.join(styles)


def render_dt_health_tab(metadata_df: pd.DataFrame):
    st.header("Dynamic Table Health & Current Status")
    st.write("Analyze the current operational state and aggregate lag metrics of your dynamic tables.")

    if metadata_df.empty:
        st.info("No metadata available for DT HEALTH tab. Check data source or collection.", icon="ℹ️")
        return

    # --- Filters for DT Health Tab ---
    st.markdown("---")
    st.subheader("Apply Filters for DT Health")

    filter_cols_dt_health_row1 = st.columns([1, 1, 1, 1])

    with filter_cols_dt_health_row1[0]:
        all_databases_dt_health = ['All'] + sorted(metadata_df['DATABASE_NAME'].unique().tolist())
        selected_database_dt_health = st.selectbox(
            "Database:", options=all_databases_dt_health, key="db_filter_dt_health"
        )
    with filter_cols_dt_health_row1[1]:
        # FIXED: Ensure explicit copy for temp_df_for_schema_options
        temp_df_for_schema_options = metadata_df.copy()
        if selected_database_dt_health != 'All':
            temp_df_for_schema_options = temp_df_for_schema_options[temp_df_for_schema_options['DATABASE_NAME'] == selected_database_dt_health].copy() # Added .copy() here

        if not temp_df_for_schema_options.empty:
            schemas_in_db_dt_health = ['All'] + sorted(temp_df_for_schema_options['SCHEMA_NAME'].unique().tolist())
        else:
            schemas_in_db_dt_health = ['All']
            st.info("No schemas found for selected Database.", icon="ℹ️")

        selected_schema_dt_health = st.selectbox(
            "Schema:", options=schemas_in_db_dt_health, key="schema_filter_dt_health"
        )
    
    # FIXED: Ensure explicit copy for df_for_table_options
    df_for_table_options = metadata_df.copy()
    if selected_database_dt_health != 'All':
        df_for_table_options = df_for_table_options[df_for_table_options['DATABASE_NAME'] == selected_database_dt_health].copy() # Added .copy() here
    if selected_schema_dt_health != 'All':
        df_for_table_options = df_for_options[df_for_table_options['SCHEMA_NAME'] == selected_schema_dt_health].copy() # Added .copy() here


    with filter_cols_dt_health_row1[2]:
        if not df_for_table_options.empty:
            all_tables_dt_health_options = ['All'] + sorted(df_for_table_options['TABLE_NAME'].unique().tolist())
            default_tables_dt_health_selected = ['All']
        else:
            all_tables_dt_health_options = ['All']
            default_tables_dt_health_selected = ['All']
            st.info("No tables found for selected DB/Schema.", icon="ℹ️")
        selected_table_dt_health = st.multiselect(
            "Table(s):", options=all_tables_dt_health_options, default=default_tables_dt_health_selected, key="table_filter_dt_health"
        )
    with filter_cols_dt_health_row1[3]:
        all_scheduling_states = ['All'] + sorted(metadata_df['SCHEDULING_STATE_STATUS'].unique().tolist())
        selected_scheduling_state = st.multiselect(
            "Scheduling State(s):", options=all_scheduling_states, default=['All'], key="scheduling_state_filter_dt_health"
        )
    
    filter_cols_dt_health_row2 = st.columns([1])
    with filter_cols_dt_health_row2[0]:
        time_format_option = st.radio(
            "Display Lag Times In:", 
            options=["mixed", "seconds", "minutes", "hours", "days"], 
            index=0, # Default to mixed
            horizontal=True,
            key="time_format_dt_health"
        )
    
    st.markdown("---")


    # --- Apply Filters to Main DataFrame ---
    #  Apply database, schema, table, and scheduling state filters first.

    filtered_metadata_df = metadata_df.copy()

    if selected_database_dt_health != 'All':
        filtered_metadata_df = filtered_metadata_df[filtered_metadata_df['DATABASE_NAME'] == selected_database_dt_health].copy()
    if selected_schema_dt_health != 'All':
        filtered_metadata_df = filtered_metadata_df[filtered_metadata_df['SCHEMA_NAME'] == selected_schema_dt_health].copy()
    if selected_table_dt_health and 'All' not in selected_table_dt_health:
        filtered_metadata_df = filtered_metadata_df[filtered_metadata_df['TABLE_NAME'].isin(selected_table_dt_health)].copy()
    elif not selected_table_dt_health:
        st.warning("No table(s) selected. Display will be empty.", icon="⚠️")
        filtered_metadata_df = pd.DataFrame()

    if selected_scheduling_state and 'All' not in selected_scheduling_state:
        filtered_metadata_df = filtered_metadata_df[filtered_metadata_df['SCHEDULING_STATE_STATUS'].isin(selected_scheduling_state)].copy()
    elif not selected_scheduling_state:
        st.warning("No scheduling state(s) selected. Display will be empty.", icon="⚠️")
        filtered_metadata_df = pd.DataFrame()

    if filtered_metadata_df.empty:
        st.info("No data available based on current filter selections. Please adjust your filters.", icon="ℹ️")
        return

    # --- Table Display with Conditional Formatting ---
    st.subheader("Detailed Dynamic Table Status")

    # --- NEW: Radio buttons to select coloring scheme ---
    color_by_option = st.radio(
        "Color Table By:",
        ('None', 'Status', 'Mean Lag', 'Max Lag', 'Time Above Target Lag', 'Lag Ratio'),
        index=0,
        horizontal=True,
        key="new_color_by_dt_health_table" # Added new_ prefix to the key
    )
    st.write("Detailed metadata and lag metrics for each dynamic table based on latest snapshot.")

    # Define thresholds for coloring -  *This is a good idea*, but put here (not in the function)
    mean_lag_thresholds = {'ok': 300, 'warning': 1800, 'critical': 3600} # 5min, 30min, 1hr in seconds
    max_lag_thresholds = {'ok': 600, 'warning': 3600, 'critical': 7200} # 10min, 1hr, 2hr in seconds
    time_above_thresholds = {'ok': 0, 'warning': 300, 'critical': 1800} # 0, 5min, 30min in seconds
    lag_ratio_thresholds = {'ok': 0.90, 'warning': 0.70, 'critical': 0.01} # 90%, 70%, 1%

    # Apply column name rename AFTER the data filtering
    dt_health_display_columns = [
        'QUALIFIED_NAME', 'SCHEDULING_STATE_STATUS', 'SCHEDULING_STATE_REASON_MESSAGE', 
        'TARGET_LAG_SEC_FMT', 'MEAN_LAG_SEC_FMT', 'MAXIMUM_LAG_SEC_FMT',
        'TIME_ABOVE_TARGET_LAG_SEC_FMT', 'TIME_WITHIN_TARGET_LAG_RATIO_FMT', # Apply .FMT
        'LATEST_DATA_TIMESTAMP', 'LAST_COMPLETED_REFRESH_STATE', 'EXECUTING_REFRESH_QUERY_ID',
        'COLLECTION_TIMESTAMP'
    ]
    
    dt_health_display_labels = {
        'QUALIFIED_NAME': 'Dynamic Table',
        'SCHEDULING_STATE_STATUS': 'Status',
        'SCHEDULING_STATE_REASON_MESSAGE': 'Reason',
        'TARGET_LAG_SEC_FMT': 'Target Lag',
        'MEAN_LAG_SEC_FMT': 'Mean Lag',
        'MAXIMUM_LAG_SEC_FMT': 'Max Lag',
        'TIME_ABOVE_TARGET_LAG_SEC_FMT': 'Time Above Lag',
        'TIME_WITHIN_TARGET_LAG_RATIO_FMT': 'Lag Ratio (%)', # Updated to show formatted ratio
        'LATEST_DATA_TIMESTAMP': 'Latest Data Time',
        'LAST_COMPLETED_REFRESH_STATE': 'Last Refresh Status',
        'EXECUTING_REFRESH_QUERY_ID': 'Executing Query ID',
        'COLLECTION_TIMESTAMP': 'Snapshot Time'
    }

    # Make a copy before renaming/applying style (as requested)
    df_for_dt_health_table = final_filtered_metadata_df.copy()
    df_for_dt_health_table = df_for_dt_health_table.rename(columns=dt_health_display_labels)

    # Apply the correct style function
    if color_by_option != 'None':
        # Apply styling function ONLY IF a color option is selected
        # Ensure that we're ONLY passing the original data to the styling
        styled_df = df_for_dt_health_table.style.apply(
            color_table_row,
            axis=1, # Apply to rows
            color_by_option=color_by_option,
            mean_lag_thresholds=mean_lag_thresholds,
            max_lag_thresholds=max_lag_thresholds,
            time_above_thresholds=time_above_thresholds,
            lag_ratio_thresholds=lag_ratio_thresholds
        )

        st.dataframe(
            styled_df, # Display styled table
            use_container_width=True
        )
    else:
        # Display the base table (without styling)
        st.dataframe(
            df_for_dt_health_table[[col for col in dt_health_display_columns if col in df_for_dt_health_table.columns]], # Show only selected columns
            use_container_width=True
        )
