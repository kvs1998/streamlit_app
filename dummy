# tabs/dt_health_tab.py
import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime, timedelta

# --- Helper function to convert seconds to a more readable format ---
def format_seconds_to_readable(seconds_series, format_type):
    if not isinstance(seconds_series, pd.Series):
        seconds_series = pd.Series([seconds_series])

    numeric_series = pd.to_numeric(seconds_series, errors='coerce')

    if numeric_series.empty or pd.isna(numeric_series).all():
        return pd.Series(["N/A"] * len(numeric_series), index=numeric_series.index)

    def format_single_second(s, f_type):
        if pd.isna(s):
            return "N/A"
        
        if f_type == "seconds":
            return f"{s:.1f}s"
        elif f_type == "minutes":
            return f"{(s / 60):.1f}m"
        elif f_type == "hours":
            return f"{(s / 3600):.1f}h"
        elif f_type == "days":
            return f"{(s / 86400):.1f}d"
        elif f_type == "mixed":
            days = int(s // 86400)
            hours = int((s % 86400) // 3600)
            minutes = int((s % 3600) // 60)
            seconds = s % 60
            
            parts = []
            if days > 0: parts.append(f"{days}d")
            if hours > 0: parts.append(f"{hours}h")
            if minutes > 0: parts.append(f"{minutes}m")
            if seconds > 0.1 and (not parts or seconds >= 1):
                parts.append(f"{seconds:.1f}s")
            
            return " ".join(parts) if parts else "0s"
        return str(s)

    return numeric_series.apply(lambda x: format_single_second(x, format_type))


# --- Helper function for Legend text formatting (scalar value) ---
def format_stale_days_for_legend(days_value):
    if pd.isna(days_value): return "N/A"
    if days_value == 1: return "1 day"
    return f"{int(days_value)} days"


# --- Define Global Colors for Row Styling ---
BG_COLOR_GOOD = '#ccffcc' # Light Green (Healthy)
BG_COLOR_WARNING = '#ffe0b3' # Light Orange (Warning/Partial Failure)
BG_COLOR_CRITICAL = '#f8d7da' # Light Red (Suspended/Failed)
BG_COLOR_NONE = '#ffffff' # Explicit white for 'None' option or NaN values


# Helper function for ROW-WISE conditional formatting
def apply_row_style(row_from_display_df, color_by_option, thresholds, original_df_full_data):
    current_qualified_name = row_from_display_df.get('Dynamic Table')

    row_original_data = pd.Series(dtype='object')
    
    if isinstance(original_df_full_data, pd.DataFrame) and \
       'QUALIFIED_NAME' in original_df_full_data.columns and \
       current_qualified_name in original_df_full_data['QUALIFIED_NAME'].values:
        
        row_original_data = original_df_full_data[
            original_df_full_data['QUALIFIED_NAME'] == current_qualified_name
        ].iloc[0]
    
    style_str = 'background-color: transparent;'

    if row_original_data.empty: 
        pass 
    elif color_by_option == 'Status':
        status = row_original_data.get('SCHEDULING_STATE_STATUS')
        last_refresh_state = row_original_data.get('LAST_COMPLETED_REFRESH_STATE')

        if status == 'SUSPENDED':
            style_str = f'background-color: {BG_COLOR_CRITICAL}'
        elif last_refresh_state == 'FAILED':
            style_str = f'background-color: {BG_COLOR_CRITICAL}'
        elif last_refresh_state in ['UPSTREAM_FAILED', 'CANCELLED', 'WARNING']:
            style_str = f'background-color: {BG_COLOR_WARNING}'
        elif status == 'RUNNING' and last_refresh_state == 'SUCCEEDED':
            style_str = f'background-color: {BG_COLOR_GOOD}'
        else: # Default for other or unknown states, assume good if not explicitly bad
            style_str = f'background-color: {BG_COLOR_GOOD}'

    elif color_by_option == 'Lag Ratio':
        ratio = row_original_data.get('TIME_WITHIN_TARGET_LAG_RATIO')
        if ratio < thresholds['lag_ratio']['critical']:
            style_str = f'background-color: {BG_COLOR_CRITICAL}'
        elif ratio < thresholds['lag_ratio']['warning']:
            style_str = f'background-color: {BG_COLOR_WARNING}'
        else:
            style_str = f'background-color: {BG_COLOR_GOOD}'
            
    elif color_by_option == 'Latest Data Time':
        latest_data_ts = row_original_data.get('LATEST_DATA_TIMESTAMP')
        if pd.isna(latest_data_ts): 
            style_str = f'background-color: {BG_COLOR_NONE}'
        else:
            try:
                time_diff_days = (datetime.now() - latest_data_ts).total_seconds() / 86400 
                
                if time_diff_days >= thresholds['latest_data_time']['critical_days']:
                    style_str = f'background-color: {BG_COLOR_CRITICAL}'
                elif time_diff_days >= thresholds['latest_data_time']['warning_days']:
                    style_str = f'background-color: {BG_COLOR_WARNING}'
                else: 
                    style_str = f'background-color: {BG_COLOR_GOOD}'
            except Exception: 
                style_str = f'background-color: {BG_COLOR_NONE}'
    
    return pd.Series(style_str, index=row_from_display_df.index, dtype='object')


def render_dt_health_tab(metadata_df: pd.DataFrame):
    st.header("Dynamic Table Health & Current Status")
    st.write("Analyze the current operational state and aggregate lag metrics of your dynamic tables.")

    if metadata_df.empty:
        st.info("No metadata available for DT HEALTH tab. Check data source or collection.", icon="ℹ️")
        return

    if 'QUALIFIED_NAME' not in metadata_df.columns:
        st.error("Error: 'QUALIFIED_NAME' column missing in metadata_df. Cannot proceed with DT Health tab.", icon="❌")
        return 
    metadata_df['QUALIFIED_NAME'] = metadata_df['QUALIFIED_NAME'].astype(str).str.upper()

    required_cols_for_lookup = [
        'DATABASE_NAME', 'SCHEMA_NAME', 'TABLE_NAME', 
        'SCHEDULING_STATE_STATUS', 'LAST_COMPLETED_REFRESH_STATE', 
        'MEAN_LAG_SEC', 'MAXIMUM_LAG_SEC', 'TIME_ABOVE_TARGET_LAG_SEC', 'TIME_WITHIN_TARGET_LAG_RATIO', 'TARGET_LAG_SEC',
        'LATEST_DATA_TIMESTAMP' 
    ]
    for col in required_cols_for_lookup:
        if col not in metadata_df.columns:
            st.warning(f"Warning: Column '{col}' missing in metadata_df. Initializing with NaNs/Defaults for safety.", icon="⚠️")
            if col.endswith('_SEC') or col.endswith('_RATIO'):
                metadata_df[col] = np.nan
            elif col.endswith('_TIMESTAMP'): 
                 metadata_df[col] = pd.NaT 
            else:
                metadata_df[col] = 'UNKNOWN'
    
    for col in ['MEAN_LAG_SEC', 'MAXIMUM_LAG_SEC', 'TIME_ABOVE_TARGET_LAG_SEC', 'TARGET_LAG_SEC']:
        metadata_df[col] = pd.to_numeric(metadata_df[col], errors='coerce')
    
    metadata_df['TIME_WITHIN_TARGET_LAG_RATIO'] = pd.to_numeric(metadata_df['TIME_WITHIN_TARGET_LAG_RATIO'], errors='coerce').fillna(0.0)

    metadata_df['LATEST_DATA_TIMESTAMP'] = pd.to_datetime(metadata_df['LATEST_DATA_TIMESTAMP'], errors='coerce')


    final_filtered_metadata_df = metadata_df.copy() 
    
    if final_filtered_metadata_df.empty:
        st.info("No Dynamic Table data available. Please adjust your filters or check data source.", icon="ℹ️")
        return


    # --- Filters for DT Health Tab (Unchanged positioning for now) ---
    st.markdown("---")
    st.subheader("Apply Filters for DT Health")

    filter_cols_dt_health_row1 = st.columns([1, 1, 1, 1])

    with filter_cols_dt_health_row1[0]:
        all_databases_dt_health = ['All'] + sorted(final_filtered_metadata_df['DATABASE_NAME'].unique().tolist())
        selected_database_dt_health = st.selectbox(
            "Database:", options=all_databases_dt_health, key="new_db_filter_dt_health"
        )
    with filter_cols_dt_health_row1[1]:
        temp_df_for_schema_options = final_filtered_metadata_df.copy()
        if selected_database_dt_health != 'All':
            temp_df_for_schema_options = temp_df_for_schema_options[temp_df_for_schema_options['DATABASE_NAME'] == selected_database_dt_health].copy()

        if not temp_df_for_schema_options.empty:
            schemas_in_db_dt_health = ['All'] + sorted(temp_df_for_schema_options['SCHEMA_NAME'].unique().tolist())
        else:
            schemas_in_db_dt_health = ['All']
            st.info("No schemas found for selected Database.", icon="ℹ️")

        selected_schema_dt_health = st.selectbox(
            "Schema:", options=schemas_in_db_dt_health, key="new_schema_filter_dt_health"
        )
    
    df_for_table_options = final_filtered_metadata_df.copy()
    if selected_database_dt_health != 'All':
        df_for_table_options = df_for_table_options[df_for_table_options['DATABASE_NAME'] == selected_database_dt_health].copy()
    if selected_schema_dt_health != 'All':
        df_for_table_options = df_for_table_options[df_for_table_options['SCHEMA_NAME'] == selected_schema_dt_health].copy()


    with filter_cols_dt_health_row1[2]:
        if not df_for_table_options.empty:
            all_tables_dt_health_options = ['All'] + sorted(df_for_table_options['TABLE_NAME'].unique().tolist())
            default_tables_dt_health_selected = ['All']
        else:
            all_tables_dt_health_options = ['All']
            default_tables_dt_health_selected = ['All']
            st.info("No tables found for selected DB/Schema.", icon="ℹ️")
        selected_table_dt_health = st.multiselect(
            "Table(s):", options=all_tables_dt_health_options, default=default_tables_dt_health_selected, key="new_table_filter_dt_health"
        )
    with filter_cols_dt_health_row1[3]:
        all_scheduling_states = ['All'] + sorted(final_filtered_metadata_df['SCHEDULING_STATE_STATUS'].unique().tolist())
        selected_scheduling_state = st.multiselect(
            "Scheduling State(s):", options=all_scheduling_states, default=['All'], key="new_scheduling_state_filter_dt_health"
        )
    
    filter_cols_dt_health_row2 = st.columns([1])
    with filter_cols_dt_health_row2[0]:
        time_format_option = st.radio(
            "Display Lag Times In:", 
            options=["mixed", "seconds", "minutes", "hours", "days"], 
            index=0,
            horizontal=True,
            key="new_time_format_dt_health"
        )
    
    st.markdown("---")


    # --- Apply Filters to Main DataFrame (re-filter based on user selections) ---
    if selected_database_dt_health != 'All':
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['DATABASE_NAME'] == selected_database_dt_health].copy()
    if selected_schema_dt_health != 'All':
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['SCHEMA_NAME'] == selected_schema_dt_health].copy()
    if selected_table_dt_health and 'All' not in selected_table_dt_health:
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['TABLE_NAME'].isin(selected_table_dt_health)].copy()
    elif not selected_table_dt_health:
        st.warning("No table(s) selected. Display will be empty.", icon="⚠️")
        final_filtered_metadata_df = pd.DataFrame()

    if selected_scheduling_state and 'All' not in selected_scheduling_state:
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['SCHEDULING_STATE_STATUS'].isin(selected_scheduling_state)].copy()
    elif not selected_scheduling_state:
        st.warning("No scheduling state(s) selected. Display will be empty.", icon="⚠️")
        final_filtered_metadata_df = pd.DataFrame()

    if final_filtered_metadata_df.empty:
        st.info("No data available based on current filter selections. Please adjust your filters.", icon="ℹ️")
        return


    # --- Detailed Dynamic Table Current Status Table Section ---
    
    # Custom CSS for legend items (to style the st.toggle widgets)
    st.markdown("""
        <style>
        .stToggle label {
            /* Keep original Streamlit toggle structure, but modify its appearance */
            padding: 0.1rem 0.5rem; /* Reduced padding to make them look like compact buttons */
            margin: 0 5px; /* Spacing between toggle "buttons" */
            border-radius: 0.25rem; /* Rounded corners */
            border: 1px solid #ccc; /* Subtle border */
            background-color: #f0f2f6; /* Light background by default */
            transition: all 0.2s ease-in-out;
            cursor: pointer;
            justify-content: center; /* Center the content inside the label */
        }
        /* Style when toggle is checked (active) */
        .stToggle input:checked + label {
            background-color: #e6f7ff; /* A subtle blue tint for active filter */
            border-color: #007bff; /* Blue border for active */
            color: #212529; /* Darker text */
        }
        /* Hide the default Streamlit toggle switch/circle */
        .stToggle label > div:first-child {
            display: none;
        }
        /* Ensure the span with color-box and text aligns correctly */
        .stToggle label span {
            display: flex;
            align-items: center;
            line-height: 1; /* Adjust line height for vertical alignment */
        }
        .color-box {
            width: 15px;
            height: 15px;
            border-radius: 3px;
            display: inline-block;
            margin-right: 5px;
            border: 1px solid #ccc;
            flex-shrink: 0; /* Prevent color box from shrinking */
        }
        .severity-label {
            font-weight: bold;
            font-size: 16px;
            white-space: nowrap;
            display: flex; /* Use flex to align with toggles if needed in same row */
            align-items: center;
            margin-right: 10px; /* Space before first toggle */
            height: 38px; /* Approximate height of a st.toggle to align vertically */
        }
        </style>
        """, unsafe_allow_html=True)

    # Initialize session state for filtering if not already present
    # We do this here, before potentially getting their values in st.toggle
    if 'legend_filters_status' not in st.session_state:
        st.session_state.legend_filters_status = {
            'Suspended / Failed': False,
            'Warning / Partial Failure': False,
            'Running (Succeeded)': False
        }
    if 'legend_filters_lag_ratio' not in st.session_state:
        st.session_state.legend_filters_lag_ratio = {
            'Critical': False,
            'Warning': False,
            'Good': False
        }
    if 'legend_filters_latest_data_time' not in st.session_state:
        st.session_state.legend_filters_latest_data_time = {
            'Critical': False,
            'Warning': False,
            'Good': False
        }

    # Helper function to update session state for legend filters (called by on_change)
    def update_legend_filter(filter_type, category_key):
        if filter_type == 'status':
            st.session_state.legend_filters_status[category_key] = not st.session_state.legend_filters_status[category_key]
        elif filter_type == 'lag_ratio':
            st.session_state.legend_filters_lag_ratio[category_key] = not st.session_state.legend_filters_lag_ratio[category_key]
        elif filter_type == 'latest_data_time':
            st.session_state.legend_filters_latest_data_time[category_key] = not st.session_state.legend_filters_latest_data_time[category_key]


    # --- Title and Radio Buttons (Now in one logical row) ---
    header_and_radio_cols = st.columns([0.4, 0.6]) # Adjust width as needed
    with header_and_radio_cols[0]:
        st.subheader("Detailed Dynamic Table Status")
    
    with header_and_radio_cols[1]:
        color_by_option = st.radio(
            "Color Table By:",
            ('None', 'Status', 'Lag Ratio', 'Latest Data Time'),
            index=0,
            horizontal=True, 
            key="new_color_by_dt_health_table"
        )
    
    # --- Severity Label and Clickable Legend Items ---
    severity_and_legend_cols = st.columns([0.15, 0.85]) # Adjust ratio to align 'Severity:' with first toggle
    
    with severity_and_legend_cols[0]:
        st.markdown("<span class='severity-label'>Severity:</span>", unsafe_allow_html=True)
    
    with severity_and_legend_cols[1]:
        # Thresholds for legend text and filtering logic
        thresholds_for_styling = { 
            'mean_lag': {'ok': 300, 'warning': 1800, 'critical': 3600},
            'max_lag': {'ok': 600, 'warning': 3600, 'critical': 7200},
            'time_above': {'ok': 0, 'warning': 300, 'critical': 1800},
            'lag_ratio': {'ok': 0.90, 'warning': 0.70, 'critical': 0.01}, 
            'latest_data_time': {
                'critical_days': 3,  
                'warning_days': 1    
            }
        }
        
        # Using st.container() with columns to ensure horizontal layout for toggles
        legend_toggles_container = st.container()
        if color_by_option != 'None':
            # Create columns within the container for the toggles
            col_crit, col_warn, col_good = legend_toggles_container.columns(3)

            if color_by_option == 'Status':
                with col_crit:
                    st.toggle(
                        label=f"<span class='color-box' style='background-color: {BG_COLOR_CRITICAL};'></span>Suspended / Failed",
                        value=st.session_state.legend_filters_status['Suspended / Failed'],
                        key="toggle_status_critical",
                        on_change=update_legend_filter,
                        args=('status', 'Suspended / Failed'), # Pass filter type and category key
                        unsafe_allow_html=True # IMPORTANT: Allow HTML in label
                    )
                with col_warn:
                    st.toggle(
                        label=f"<span class='color-box' style='background-color: {BG_COLOR_WARNING};'></span>Warning / Partial Failure",
                        value=st.session_state.legend_filters_status['Warning / Partial Failure'],
                        key="toggle_status_warning",
                        on_change=update_legend_filter,
                        args=('status', 'Warning / Partial Failure'),
                        unsafe_allow_html=True
                    )
                with col_good:
                    st.toggle(
                        label=f"<span class='color-box' style='background-color: {BG_COLOR_GOOD};'></span>Running (Succeeded)",
                        value=st.session_state.legend_filters_status['Running (Succeeded)'],
                        key="toggle_status_good",
                        on_change=update_legend_filter,
                        args=('status', 'Running (Succeeded)'),
                        unsafe_allow_html=True
                    )
            elif color_by_option == 'Lag Ratio':
                threshold_set = thresholds_for_styling['lag_ratio']
                def format_legend_value_ratio(val_raw):
                    if pd.isna(val_raw): return "N/A"
                    return f"{round(val_raw * 100, 1)}%"
                
                critical_val_fmt = format_legend_value_ratio(threshold_set['critical'])
                warning_val_fmt = format_legend_value_ratio(threshold_set['warning'])
                ok_val_fmt = format_legend_value_ratio(threshold_set['ok'])

                with col_crit:
                    st.toggle(
                        label=f"<span class='color-box' style='background-color: {BG_COLOR_CRITICAL};'></span>Critical (< {critical_val_fmt})",
                        value=st.session_state.legend_filters_lag_ratio['Critical'],
                        key="toggle_lag_ratio_critical",
                        on_change=update_legend_filter,
                        args=('lag_ratio', 'Critical'),
                        unsafe_allow_html=True
                    )
                with col_warn:
                    st.toggle(
                        label=f"<span class='color-box' style='background-color: {BG_COLOR_WARNING};'></span>Warning (< {warning_val_fmt})",
                        value=st.session_state.legend_filters_lag_ratio['Warning'],
                        key="toggle_lag_ratio_warning",
                        on_change=update_legend_filter,
                        args=('lag_ratio', 'Warning'),
                        unsafe_allow_html=True
                    )
                with col_good:
                    st.toggle(
                        label=f"<span class='color-box' style='background-color: {BG_COLOR_GOOD};'></span>Good (>= {ok_val_fmt})",
                        value=st.session_state.legend_filters_lag_ratio['Good'],
                        key="toggle_lag_ratio_good",
                        on_change=update_legend_filter,
                        args=('lag_ratio', 'Good'),
                        unsafe_allow_html=True
                    )
            elif color_by_option == 'Latest Data Time':
                critical_val_days = thresholds_for_styling['latest_data_time']['critical_days']
                warning_val_days = thresholds_for_styling['latest_data_time']['warning_days']
                
                critical_text = format_stale_days_for_legend(critical_val_days)
                warning_text = format_stale_days_for_legend(warning_val_days)

                with col_crit:
                    st.toggle(
                        label=f"<span class='color-box' style='background-color: {BG_COLOR_CRITICAL};'></span>{critical_text} or older",
                        value=st.session_state.legend_filters_latest_data_time['Critical'],
                        key="toggle_time_critical",
                        on_change=update_legend_filter,
                        args=('latest_data_time', 'Critical'),
                        unsafe_allow_html=True
                    )
                with col_warn:
                    st.toggle(
                        label=f"<span class='color-box' style='background-color: {BG_COLOR_WARNING};'></span>{warning_text} to < {critical_val_days} days old",
                        value=st.session_state.legend_filters_latest_data_time['Warning'],
                        key="toggle_time_warning",
                        on_change=update_legend_filter,
                        args=('latest_data_time', 'Warning'),
                        unsafe_allow_html=True
                    )
                with col_good:
                    st.toggle(
                        label=f"<span class='color-box' style='background-color: {BG_COLOR_GOOD};'></span>Less than {warning_text} old",
                        value=st.session_state.legend_filters_latest_data_time['Good'],
                        key="toggle_time_good",
                        on_change=update_legend_filter,
                        args=('latest_data_time', 'Good'),
                        unsafe_allow_html=True
                    )
        
    st.write("Detailed metadata and lag metrics for each dynamic table based on latest snapshot.")

    if final_filtered_metadata_df.empty:
        st.info("No data available based on current filter selections. Please adjust your filters.", icon="ℹ️")
        return

    # --- Apply Legend Filters to the DataFrame ---
    # Start with the full filtered_metadata_df (already filtered by selectboxes above)
    filtered_by_legend_df = final_filtered_metadata_df.copy()

    # Reset all filters if "None" is selected
    if color_by_option == 'None':
        # No specific legend filters apply, so don't filter `filtered_by_legend_df` further
        # Also, reset all legend toggles to False
        for key in st.session_state.legend_filters_status:
            st.session_state.legend_filters_status[key] = False
        for key in st.session_state.legend_filters_lag_ratio:
            st.session_state.legend_filters_lag_ratio[key] = False
        for key in st.session_state.legend_filters_latest_data_time:
            st.session_state.legend_filters_latest_data_time[key] = False

    elif color_by_option == 'Status':
        active_filters = [k for k, v in st.session_state.legend_filters_status.items() if v]
        if active_filters: 
            status_conditions = []
            if 'Suspended / Failed' in active_filters:
                status_conditions.append(
                    (filtered_by_legend_df['SCHEDULING_STATE_STATUS'] == 'SUSPENDED') |
                    (filtered_by_legend_df['LAST_COMPLETED_REFRESH_STATE'] == 'FAILED')
                )
            if 'Warning / Partial Failure' in active_filters:
                status_conditions.append(
                    (filtered_by_legend_df['LAST_COMPLETED_REFRESH_STATE'].isin(['UPSTREAM_FAILED', 'CANCELLED', 'WARNING']))
                )
            if 'Running (Succeeded)' in active_filters:
                status_conditions.append(
                    (filtered_by_legend_df['SCHEDULING_STATE_STATUS'] == 'RUNNING') & 
                    (filtered_by_legend_df['LAST_COMPLETED_REFRESH_STATE'] == 'SUCCEEDED')
                )
            
            if status_conditions:
                combined_condition = status_conditions[0]
                for cond in status_conditions[1:]:
                    combined_condition = combined_condition | cond
                filtered_by_legend_df = filtered_by_legend_df[combined_condition]
            else: 
                # If no legend filter selected for Status, but 'Status' is chosen, show ALL status types
                # To achieve this, don't apply any filter here if active_filters is empty.
                pass 

    elif color_by_option == 'Lag Ratio':
        active_filters = [k for k, v in st.session_state.legend_filters_lag_ratio.items() if v]
        if active_filters:
            lag_ratio_conditions = []
            
            # Map legend category names to actual numeric ranges using thresholds_for_styling
            if 'Critical' in active_filters:
                lag_ratio_conditions.append(filtered_by_legend_df['TIME_WITHIN_TARGET_LAG_RATIO'] < thresholds_for_styling['lag_ratio']['critical'])
            if 'Warning' in active_filters:
                # Warning range: >= warning_threshold_value AND < critical_threshold_value
                lag_ratio_conditions.append(
                    (filtered_by_legend_df['TIME_WITHIN_TARGET_LAG_RATIO'] >= thresholds_for_styling['lag_ratio']['critical']) & # From critical. It seems you intended this to be low for critical?
                    (filtered_by_legend_df['TIME_WITHIN_TARGET_LAG_RATIO'] < thresholds_for_styling['lag_ratio']['warning']) # To warning threshold
                )
                # Correction based on your legend: Critical (< 1.0%), Warning (< 70.0%), Good (>= 90.0%)
                # This implies:
                # Critical: ratio < 0.01
                # Warning: 0.01 <= ratio < 0.70
                # Good: ratio >= 0.70
                # Let's adjust filtering ranges here to match the legend text's interpretation of thresholds
            
            # Recalculating conditions for Lag Ratio based on legend's implicit ranges:
            lag_ratio_actual_conditions = []
            if 'Critical' in active_filters:
                lag_ratio_actual_conditions.append(filtered_by_legend_df['TIME_WITHIN_TARGET_LAG_RATIO'] < thresholds_for_styling['lag_ratio']['critical']) # < 0.01
            if 'Warning' in active_filters:
                lag_ratio_actual_conditions.append(
                    (filtered_by_legend_df['TIME_WITHIN_TARGET_LAG_RATIO'] >= thresholds_for_styling['lag_ratio']['critical']) & # >= 0.01
                    (filtered_by_legend_df['TIME_WITHIN_TARGET_LAG_RATIO'] < thresholds_for_styling['lag_ratio']['warning']) # < 0.70
                )
            if 'Good' in active_filters:
                lag_ratio_actual_conditions.append(filtered_by_legend_df['TIME_WITHIN_TARGET_LAG_RATIO'] >= thresholds_for_styling['lag_ratio']['warning']) # >= 0.70
            
            if lag_ratio_actual_conditions:
                combined_condition = lag_ratio_actual_conditions[0]
                for cond in lag_ratio_actual_conditions[1:]:
                    combined_condition = combined_condition | cond
                filtered_by_legend_df = filtered_by_legend_df[combined_condition]
            else:
                pass # Show all if no legend filter selected for this mode

    elif color_by_option == 'Latest Data Time':
        active_filters = [k for k, v in st.session_state.legend_filters_latest_data_time.items() if v]
        if active_filters:
            latest_data_conditions = []
            
            # Calculate time_diff_days for each row, handle NaT (Not a Time)
            filtered_by_legend_df['temp_time_diff_days'] = (datetime.now() - filtered_by_legend_df['LATEST_DATA_TIMESTAMP']).dt.total_seconds() / 86400
            
            # Recalculating conditions for Latest Data Time based on legend's implicit ranges:
            if 'Critical' in active_filters:
                latest_data_conditions.append(filtered_by_legend_df['temp_time_diff_days'] >= thresholds_for_styling['latest_data_time']['critical_days']) # >= 3 days
            if 'Warning' in active_filters:
                latest_data_conditions.append(
                    (filtered_by_legend_df['temp_time_diff_days'] >= thresholds_for_styling['latest_data_time']['warning_days']) & # >= 1 day
                    (filtered_by_legend_df['temp_time_diff_days'] < thresholds_for_styling['latest_data_time']['critical_days']) # < 3 days
                )
            if 'Good' in active_filters:
                latest_data_conditions.append(filtered_by_legend_df['temp_time_diff_days'] < thresholds_for_styling['latest_data_time']['warning_days']) # < 1 day
            
            if latest_data_conditions:
                combined_condition = latest_data_conditions[0]
                for cond in latest_data_conditions[1:]:
                    combined_condition = combined_condition | cond
                filtered_by_legend_df = filtered_by_legend_df[combined_condition]
            else:
                pass # Show all if no legend filter selected for this mode

            filtered_by_legend_df = filtered_by_legend_df.drop(columns=['temp_time_diff_days']) # Clean up temp column
        
    # --- Check if df_for_display is empty after legend filtering ---
    if filtered_by_legend_df.empty:
        st.info("No data available based on current legend selections. Please adjust your legend filters.", icon="ℹ️")
        return

    # --- Use filtered_by_legend_df as the base for final display and sorting ---
    df_for_display = filtered_by_legend_df.copy()
    
    # Apply formatting for display to new columns
    df_for_display['TARGET_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['TARGET_LAG_SEC'], time_format_option)
    df_for_display['MEAN_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['MEAN_LAG_SEC'], time_format_option)
    df_for_display['MAXIMUM_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['MAXIMUM_LAG_SEC'], time_format_option)
    df_for_display['TIME_ABOVE_TARGET_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['TIME_ABOVE_TARGET_LAG_SEC'], time_format_option)
    df_for_display['TIME_WITHIN_TARGET_LAG_RATIO_FMT'] = df_for_display['TIME_WITHIN_TARGET_LAG_RATIO'].apply(lambda x: f"{round(x * 100, 1)}%") 


    # Define display columns and their labels
    dt_health_display_columns_order = [
        'QUALIFIED_NAME',
        'SCHEDULING_STATE_STATUS', 'SCHEDULING_STATE_REASON_MESSAGE', 
        'TARGET_LAG_SEC_FMT', 'MEAN_LAG_SEC_FMT', 'MAXIMUM_LAG_SEC_FMT',
        'TIME_ABOVE_TARGET_LAG_SEC_FMT', 'TIME_WITHIN_TARGET_LAG_RATIO_FMT', 
        'LATEST_DATA_TIMESTAMP', 
        'LAST_COMPLETED_REFRESH_STATE', 'EXECUTING_REFRESH_QUERY_ID',
        'COLLECTION_TIMESTAMP'
    ]
    
    dt_health_display_labels = {
        'QUALIFIED_NAME': 'Dynamic Table',
        'SCHEDULING_STATE_STATUS': 'Status',
        'SCHEDULING_STATE_REASON_MESSAGE': 'Reason',
        'TARGET_LAG_SEC_FMT': 'Target Lag',
        'MEAN_LAG_SEC_FMT': 'Mean Lag',
        'MAXIMUM_LAG_SEC_FMT': 'Max Lag',
        'TIME_ABOVE_TARGET_LAG_SEC_FMT': 'Time Above Lag',
        'TIME_WITHIN_TARGET_LAG_RATIO_FMT': 'Lag Ratio (%)',
        'LATEST_DATA_TIMESTAMP': 'Latest Data Time', 
        'LAST_COMPLETED_REFRESH_STATE': 'Last Refresh Status',
        'EXECUTING_REFRESH_QUERY_ID': 'Executing Query ID',
        'COLLECTION_TIMESTAMP': 'Snapshot Time'
    }

    # Select and rename columns for the display DataFrame
    df_for_display = df_for_display[[col for col in dt_health_display_columns_order if col in df_for_display.columns]].rename(columns=dt_health_display_labels)


    # --- Apply Sorting ---
    status_and_refresh_severity_sort_order = {
        ('SUSPENDED', 'FAILED'): 0, ('SUSPENDED', 'UPSTREAM_FAILED'): 1,
        ('SUSPENDED', 'CANCELLED'): 2, ('SUSPENDED', 'WARNING'): 3,
        ('SUSPENDED', 'SUCCEEDED'): 4, ('SUSPENDED', 'UNKNOWN'): 5,
        ('RUNNING', 'FAILED'): 6, 
        ('RUNNING', 'UPSTREAM_FAILED'): 7, ('RUNNING', 'CANCELLED'): 8,
        ('RUNNING', 'WARNING'): 9,
        ('RUNNING', 'SUCCEEDED'): 10,
        ('UNKNOWN', 'UNKNOWN'): 11, (None, None): 12 
    }

    # Use the filtered_by_legend_df as the basis for sorting logic keys
    filtered_by_legend_df['COMPOUND_STATUS_SORT_KEY'] = filtered_by_legend_df.apply(
        lambda row: status_and_refresh_severity_sort_order.get(
            (row.get('SCHEDULING_STATE_STATUS'), row.get('LAST_COMPLETED_REFRESH_STATE')),
            status_and_refresh_severity_sort_order[(None, None)]
        ), axis=1
    )

    def get_lag_ratio_sort_key(row, thresholds):
        ratio = row.get('TIME_WITHIN_TARGET_LAG_RATIO')
        if pd.isna(ratio): return 99 
        if ratio < thresholds['lag_ratio']['critical']: return 0 
        if ratio < thresholds['lag_ratio']['warning']: return 1 
        return 2 

    def get_latest_data_time_sort_key(row, thresholds):
        latest_data_ts = row.get('LATEST_DATA_TIMESTAMP')
        if pd.isna(latest_data_ts): return 99 
        time_diff_days = (datetime.now() - latest_data_ts).total_seconds() / 86400
        if time_diff_days >= thresholds['latest_data_time']['critical_days']: return 0 
        if time_diff_days >= thresholds['latest_data_time']['warning_days']: return 1 
        return 2 


    final_df_for_display_sorted = df_for_display.copy() 
    sort_columns = []
    ascending_flags = []

    if color_by_option == 'None' or color_by_option == 'Status':
        sort_columns = ['COMPOUND_STATUS_SORT_KEY']
        ascending_flags = [True] 
    elif color_by_option == 'Lag Ratio':
        filtered_by_legend_df['LAG_RATIO_SORT_KEY'] = filtered_by_legend_df.apply(
            lambda row: get_lag_ratio_sort_key(row, thresholds_for_styling), axis=1
        )
        sort_columns = ['LAG_RATIO_SORT_KEY', 'TIME_WITHIN_TARGET_LAG_RATIO'] 
        ascending_flags = [True, True] 
    elif color_by_option == 'Latest Data Time':
        filtered_by_legend_df['LATEST_DATA_TIME_SORT_KEY'] = filtered_by_legend_df.apply(
            lambda row: get_latest_data_time_sort_key(row, thresholds_for_styling), axis=1
        )
        sort_columns = ['LATEST_DATA_TIME_SORT_KEY', 'LATEST_DATA_TIMESTAMP'] 
        ascending_flags = [True, True] 

    if sort_columns:
        # Sort using the potentially filtered_by_legend_df's data and new sort keys
        sort_order_indices = filtered_by_legend_df.sort_values(
            by=sort_columns, ascending=ascending_flags, na_position='last'
        ).index
        final_df_for_display_sorted = df_for_display.loc[sort_order_indices].reset_index(drop=True)
        
    # --- Apply Styling (row-wise background color) ---
    if color_by_option != 'None':
        styled_df = final_df_for_display_sorted.style.apply(
            lambda row_display: apply_row_style(
                row_display,             
                color_by_option,         
                thresholds_for_styling,  
                # Pass the UNFILTERED metadata_df so the styling logic has access to all original data for lookup,
                # even if the row was included by legend filtering.
                final_filtered_metadata_df 
            ), 
            axis=1 
        )
        st.dataframe(
            styled_df,
            use_container_width=True
        )
    else: 
        st.dataframe(
            final_df_for_display_sorted, 
            use_container_width=True
        )
