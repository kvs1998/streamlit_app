# tabs/dt_health_tab.py
import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px

# --- Helper function to convert seconds to a more readable format ---
def format_seconds_to_readable(seconds_series, format_type):
    if format_type == "seconds":
        return seconds_series.round(1).astype(str) + "s"
    elif format_type == "minutes":
        return (seconds_series / 60).round(1).astype(str) + "m"
    elif format_type == "hours":
        return (seconds_series / 3600).round(1).astype(str) + "h"
    elif format_type == "days":
        return (seconds_series / 86400).round(1).astype(str) + "d"
    elif format_type == "mixed":
        def mix_format(s):
            if pd.isna(s) or s is None: return "N/A"
            s = float(s)
            if s == 0: return "0s"

            days = int(s // 86400)
            hours = int((s % 86400) // 3600)
            minutes = int((s % 3600) // 60)
            seconds = s % 60
            
            parts = []
            if days > 0: parts.append(f"{days}d")
            if hours > 0: parts.append(f"{hours}h")
            if minutes > 0: parts.append(f"{minutes}m")
            if seconds > 0 and (not parts or seconds >= 1):
                parts.append(f"{seconds:.1f}s")
            
            return " ".join(parts) if parts else "0s"
        return seconds_series.apply(mix_format)
    return seconds_series


# --- Define Global Colors for Row Styling ---
BG_COLOR_GOOD = '#ccffcc' # Light Green
BG_COLOR_WARNING = '#ffe0b3' # Light Orange
BG_COLOR_CRITICAL = '#ffcccc' # Light Red
BG_COLOR_INFO = '#cce5ff' # Light Blue for suspended


# Helper function for ROW-WISE conditional formatting
def apply_row_style(row_original_data, display_column_names, color_by_option, thresholds):
    """
    Applies background color to the entire row based on the selected metric and its thresholds.
    Returns a Pandas Series of CSS style strings, with index matching DataFrame column names.
    This function receives `row_original_data` (a Series from final_filtered_metadata_df).
    """
    style_str = ''

    if color_by_option == 'Status':
        status = row_original_data.get('SCHEDULING_STATE_STATUS')
        last_refresh_state = row_original_data.get('LAST_COMPLETED_REFRESH_STATE')
        if status == 'SUSPENDED':
            style_str = f'background-color: {BG_COLOR_INFO}'
        elif status == 'RUNNING' and last_refresh_state in ['FAILED', 'UPSTREAM_FAILED', 'CANCELLED']:
            style_str = f'background-color: {BG_COLOR_WARNING}'
        elif status == 'RUNNING' and last_refresh_state == 'SUCCEEDED':
             style_str = f'background-color: {BG_COLOR_GOOD}'
        elif last_refresh_state == 'FAILED':
             style_str = f'background-color: {BG_COLOR_CRITICAL}'
        elif last_refresh_state in ['WARNING', 'UPSTREAM_FAILED', 'CANCELLED']:
             style_str = f'background-color: {BG_COLOR_WARNING}'

    elif color_by_option == 'Mean Lag':
        lag = row_original_data.get('MEAN_LAG_SEC')
        if pd.notna(lag):
            if lag >= thresholds['mean_lag']['critical']:
                style_str = f'background-color: {BG_COLOR_CRITICAL}'
            elif lag >= thresholds['mean_lag']['warning']:
                style_str = f'background-color: {BG_COLOR_WARNING}'
            elif lag < thresholds['mean_lag']['ok']:
                style_str = f'background-color: {BG_COLOR_GOOD}'

    elif color_by_option == 'Max Lag':
        lag = row_original_data.get('MAXIMUM_LAG_SEC')
        if pd.notna(lag):
            if lag >= thresholds['max_lag']['critical']:
                style_str = f'background-color: {BG_COLOR_CRITICAL}'
            elif lag >= thresholds['max_lag']['warning']:
                style_str = f'background-color: {BG_COLOR_WARNING}'
            elif lag < thresholds['max_lag']['ok']:
                style_str = f'background-color: {BG_COLOR_GOOD}'

    elif color_by_option == 'Time Above Target Lag':
        time_above = row_original_data.get('TIME_ABOVE_TARGET_LAG_SEC')
        if pd.notna(time_above):
            if time_above > thresholds['time_above']['critical']:
                style_str = f'background-color: {BG_COLOR_CRITICAL}'
            elif time_above > thresholds['time_above']['warning']:
                style_str = f'background-color: {BG_COLOR_WARNING}'
            elif time_above <= thresholds['time_above']['ok']:
                style_str = f'background-color: {BG_COLOR_GOOD}'

    elif color_by_option == 'Lag Ratio':
        ratio = row_original_data.get('TIME_WITHIN_TARGET_LAG_RATIO')
        if pd.notna(ratio):
            if ratio < thresholds['lag_ratio']['critical']: # Lower ratio is worse
                style_str = f'background-color: {BG_COLOR_CRITICAL}'
            elif ratio < thresholds['lag_ratio']['warning']:
                style_str = f'background-color: {BG_COLOR_WARNING}'
            elif ratio >= thresholds['lag_ratio']['ok']:
                style_str = f'background-color: {BG_COLOR_GOOD}'
    
    # --- CRITICAL FIX: Return a Series with the correct display column names as index ---
    # `display_column_names` will be passed from the main function.
    return pd.Series(style_str, index=display_column_names)


# --- REMOVED get_active_dt_names_from_snowflake function ---


def render_dt_health_tab(metadata_df: pd.DataFrame):
    st.header("Dynamic Table Health & Current Status")
    st.write("Analyze the current operational state and aggregate lag metrics of your dynamic tables.")

    if metadata_df.empty:
        st.info("No metadata available for DT HEALTH tab. Check data source or collection.", icon="ℹ️")
        return

    # Ensure all required numeric columns are present and numeric
    required_numeric_cols = ['MEAN_LAG_SEC', 'MAXIMUM_LAG_SEC', 'TIME_ABOVE_TARGET_LAG_SEC', 'TIME_WITHIN_TARGET_LAG_RATIO', 'TARGET_LAG_SEC']
    for col in required_numeric_cols:
        if col not in metadata_df.columns:
            metadata_df[col] = np.nan
        metadata_df[col] = pd.to_numeric(metadata_df[col], errors='coerce')


    # --- Direct use of metadata_df as the filtered_metadata_df ---
    filtered_metadata_df = metadata_df.copy() 

    if filtered_metadata_df.empty:
        st.info("No Dynamic Table data available. Please adjust your filters or check data source.", icon="ℹ️")
        return


    # --- Filters for DT Health Tab ---
    st.markdown("---")
    st.subheader("Apply Filters for DT Health")

    filter_cols_dt_health_row1 = st.columns([1, 1, 1, 1])

    with filter_cols_dt_health_row1[0]:
        all_databases_dt_health = ['All'] + sorted(filtered_metadata_df['DATABASE_NAME'].unique().tolist())
        selected_database_dt_health = st.selectbox(
            "Database:", options=all_databases_dt_health, key="new_db_filter_dt_health"
        )
    with filter_cols_dt_health_row1[1]:
        temp_df_for_schema_options = filtered_metadata_df.copy()
        if selected_database_dt_health != 'All':
            temp_df_for_schema_options = temp_df_for_schema_options[temp_df_for_schema_options['DATABASE_NAME'] == selected_database_dt_health].copy()

        if not temp_df_for_schema_options.empty:
            schemas_in_db_dt_health = ['All'] + sorted(temp_df_for_schema_options['SCHEMA_NAME'].unique().tolist())
        else:
            schemas_in_db_dt_health = ['All']
            st.info("No schemas found for selected Database.", icon="ℹ️")

        selected_schema_dt_health = st.selectbox(
            "Schema:", options=schemas_in_db_dt_health, key="new_schema_filter_dt_health"
        )
    
    df_for_table_options = filtered_metadata_df.copy()
    if selected_database_dt_health != 'All':
        df_for_table_options = df_for_table_options[df_for_table_options['DATABASE_NAME'] == selected_database_dt_health].copy()
    if selected_schema_dt_health != 'All':
        df_for_table_options = df_for_table_options[df_for_table_options['SCHEMA_NAME'] == selected_schema_dt_health].copy()


    with filter_cols_dt_health_row1[2]:
        if not df_for_table_options.empty:
            all_tables_dt_health_options = ['All'] + sorted(df_for_table_options['TABLE_NAME'].unique().tolist())
            default_tables_dt_health_selected = ['All']
        else:
            all_tables_dt_health_options = ['All']
            default_tables_dt_health_selected = ['All']
            st.info("No tables found for selected DB/Schema.", icon="ℹ️")
        selected_table_dt_health = st.multiselect(
            "Table(s):", options=all_tables_dt_health_options, default=default_tables_dt_health_selected, key="new_table_filter_dt_health"
        )
    with filter_cols_dt_health_row1[3]:
        all_scheduling_states = ['All'] + sorted(filtered_metadata_df['SCHEDULING_STATE_STATUS'].unique().tolist())
        selected_scheduling_state = st.multiselect(
            "Scheduling State(s):", options=all_scheduling_states, default=['All'], key="new_scheduling_state_filter_dt_health"
        )
    
    filter_cols_dt_health_row2 = st.columns([1])
    with filter_cols_dt_health_row2[0]:
        time_format_option = st.radio(
            "Display Lag Times In:", 
            options=["mixed", "seconds", "minutes", "hours", "days"], 
            index=0,
            horizontal=True,
            key="new_time_format_dt_health"
        )
    
    st.markdown("---")


    # --- Apply Filters to Main DataFrame (re-filter based on user selections) ---
    final_filtered_metadata_df = filtered_metadata_df.copy() 

    if selected_database_dt_health != 'All':
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['DATABASE_NAME'] == selected_database_dt_health].copy()
    if selected_schema_dt_health != 'All':
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['SCHEMA_NAME'] == selected_schema_dt_health].copy()
    if selected_table_dt_health and 'All' not in selected_table_dt_health:
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['TABLE_NAME'].isin(selected_table_dt_health)].copy()
    elif not selected_table_dt_health:
        st.warning("No table(s) selected. Display will be empty.", icon="⚠️")
        final_filtered_metadata_df = pd.DataFrame()

    if selected_scheduling_state and 'All' not in selected_scheduling_state:
        final_filtered_metadata_df = final_filtered_metadata_df[final_filtered_metadata_df['SCHEDULING_STATE_STATUS'].isin(selected_scheduling_state)].copy()
    elif not selected_scheduling_state:
        st.warning("No scheduling state(s) selected. Display will be empty.", icon="⚠️")
        final_filtered_metadata_df = pd.DataFrame()

    if final_filtered_metadata_df.empty:
        st.info("No data available based on current filter selections. Please adjust your filters.", icon="ℹ️")
        return


    # --- KPIs and Primary Charts Section ---
    kpi_chart_cols = st.columns([0.4, 0.6])

    with kpi_chart_cols[0]: # Left Column: KPIs
        st.subheader("Current Dynamic Table Health KPIs")
        
        total_dt_monitored = final_filtered_metadata_df['QUALIFIED_NAME'].nunique()
        running_dt_count = final_filtered_metadata_df[
            (final_filtered_metadata_df['SCHEDULING_STATE_STATUS'] == 'RUNNING') & 
            (final_filtered_metadata_df['LAST_COMPLETED_REFRESH_STATE'] == 'SUCCEEDED')
        ]['QUALIFIED_NAME'].nunique()

        suspended_dt_count = final_filtered_metadata_df[
            final_filtered_metadata_df['SCHEDULING_STATE_STATUS'] == 'SUSPENDED'
        ]['QUALIFIED_NAME'].nunique()
        
        running_but_failed_dt_count = final_filtered_metadata_df[
            (final_filtered_metadata_df['SCHEDULING_STATE_STATUS'] == 'RUNNING') & 
            (final_filtered_metadata_df['LAST_COMPLETED_REFRESH_STATE'].isin(['FAILED', 'UPSTREAM_FAILED', 'CANCELLED']))
        ]['QUALIFIED_NAME'].nunique()

        executing_refresh_dt_count = final_filtered_metadata_df[final_filtered_metadata_df['EXECUTING_REFRESH_QUERY_ID'].notna()]['QUALIFIED_NAME'].nunique()
        
        avg_mean_lag = final_filtered_metadata_df['MEAN_LAG_SEC'].mean()
        max_lag = final_filtered_metadata_df['MAXIMUM_LAG_SEC'].max()

        avg_mean_lag_fmt = format_seconds_to_readable(pd.Series([avg_mean_lag]), time_format_option).iloc[0] if not pd.isna(avg_mean_lag) else "N/A"
        max_lag_fmt = format_seconds_to_readable(pd.Series([max_lag]), time_format_option).iloc[0] if not pd.isna(max_lag) else "N/A"


        kpi_cols_dt_health_row1 = st.columns(2)
        with kpi_cols_dt_health_row1[0]:
            st.markdown(f"<p style='font-size:14px; margin-bottom:0;'>Total DTs Monitored</p>", unsafe_allow_html=True)
            st.markdown(f"<h3 style='margin-top:0;'>{total_dt_monitored}</h3>", unsafe_allow_html=True)
            st.markdown(f"<p style='font-size:14px; color:blue; margin-bottom:0;'>Refreshing Now</p>", unsafe_allow_html=True)
            st.markdown(f"<h3 style='margin-top:0;'>{executing_refresh_dt_count} tables</h3>", unsafe_allow_html=True)
        with kpi_cols_dt_health_row1[1]:
            st.markdown(f"<p style='font-size:14px; color:green; margin-bottom:0;'>Running (Healthy) DTs</p>", unsafe_allow_html=True)
            st.markdown(f"<h3 style='margin-top:0;'>{running_dt_count}</h3>", unsafe_allow_html=True)
            st.markdown(f"<p style='font-size:14px; margin-bottom:0;'>Avg Mean Lag</p>", unsafe_allow_html=True)
            st.markdown(f"<h3 style='margin-top:0;'>{avg_mean_lag_fmt}</h3>", unsafe_allow_html=True)

        kpi_cols_dt_health_row2 = st.columns(2)
        with kpi_cols_dt_health_row2[0]:
            st.markdown(f"<p style='font-size:14px; color:red; margin-bottom:0;'>Suspended DTs</p>", unsafe_allow_html=True)
            st.markdown(f"<h3 style='margin-top:0;'>{suspended_dt_count}</h3>", unsafe_allow_html=True)
        with kpi_cols_dt_health_row2[1]:
            st.markdown(f"<p style='font-size:14px; margin-bottom:0;'>Max Lag</p>", unsafe_allow_html=True)
            st.markdown(f"<h3 style='margin-top:0;'>{max_lag_fmt}</h3>", unsafe_allow_html=True)
            
        kpi_cols_dt_health_row3 = st.columns(1) 
        with kpi_cols_dt_health_row3[0]:
            st.markdown(f"<p style='font-size:14px; color:orange; margin-bottom:0;'>Running (Actively Failing)</p>", unsafe_allow_html=True)
            st.markdown(f"<h3 style='margin-top:0;'>{running_but_failed_dt_count} tables</h3>", unsafe_allow_html=True)


    with kpi_chart_cols[1]: # Right Column: Scheduling State and Target Lag Type Distribution Charts
        st.subheader("Scheduling & Lag Type Distribution")

        scheduling_state_counts = final_filtered_metadata_df['SCHEDULING_STATE_STATUS'].value_counts().reset_index()
        scheduling_state_counts.columns = ['Status', 'Count']
        
        target_lag_type_counts = final_filtered_metadata_df['TARGET_LAG_TYPE'].value_counts().reset_index()
        target_lag_type_counts.columns = ['Lag Type', 'Count']

        chart_rows = st.columns(2)
        with chart_rows[0]:
            if not scheduling_state_counts.empty:
                fig_scheduling_state = px.pie(scheduling_state_counts, 
                                          values='Count', 
                                          names='Status', 
                                          title='Scheduling State',
                                          hole=0.3,
                                          color_discrete_map={'RUNNING': 'green', 'SUSPENDED': 'red', 'UNKNOWN': 'grey'})
                fig_scheduling_state.update_traces(textposition='inside', textinfo='percent')
                st.plotly_chart(fig_scheduling_state, use_container_width=True)
            else:
                st.info("No scheduling state data.", icon="ℹ️")


        with chart_rows[1]:
            if not target_lag_type_counts.empty:
                fig_lag_type = px.pie(target_lag_type_counts,
                                  values='Count',
                                  names='Lag Type',
                                  title='Target Lag Type',
                                  hole=0.3,
                                  color_discrete_map={'USER_DEFINED': 'blue', 'DOWNSTREAM': 'purple', 'UNKNOWN_TYPE': 'grey'})
                fig_lag_type.update_traces(textposition='inside', textinfo='percent')
                st.plotly_chart(fig_lag_type, use_container_width=True)
            else:
                st.info("No target lag type data.", icon="ℹ️")

    st.divider()

    # --- Charts for Detailed Tracking (Lag Distribution, Last Refresh Status, Time Within Ratio) ---
    st.subheader("Performance & Compliance Insights")
    
    chart_detail_row1_cols = st.columns(2)

    with chart_detail_row1_cols[0]: # Mean Lag Distribution (Histogram)
        st.markdown("<p style='font-size:16px;'><b>Mean Lag Distribution</b></p>", unsafe_allow_html=True)
        st.write("Distribution of dynamic tables by their mean lag time.")

        mean_lag_data_seconds = final_filtered_metadata_df['MEAN_LAG_SEC'].dropna().copy()

        if not mean_lag_data_seconds.empty:
            if time_format_option == "minutes":
                unit_divisor_mean_lag = 60
            elif time_format_option == "hours":
                unit_divisor_mean_lag = 3600
            elif time_format_option == "days":
                unit_divisor_mean_lag = 86400
            else:
                unit_divisor_mean_lag = 1
            
            mean_lag_values_to_plot = mean_lag_data_seconds / unit_divisor_mean_lag

            if not mean_lag_values_to_plot.empty:
                min_val = mean_lag_values_to_plot.min()
                max_val = mean_val
                
                # Check for zero range to prevent division by zero or empty bins
                if max_val - min_val < 1e-6:
                    if max_val == 0:
                        binsize_plot_unit_mean_lag = 1.0 # Default bin size if all are zero
                    else:
                        binsize_plot_unit_mean_lag = max_val / 5 if max_val > 0 else 1.0
                else:
                    num_desired_bins = 20
                    binsize_plot_unit_mean_lag = (max_val - min_val) / num_desired_bins
                    
                    if time_format_option == 'minutes':
                        binsize_plot_unit_mean_lag = max(0.1, binsize_plot_unit_mean_lag)
                    elif time_format_option == 'hours':
                        binsize_plot_unit_mean_lag = max(0.01, binsize_plot_unit_mean_lag)
                    elif time_format_option == 'days':
                        binsize_plot_unit_mean_lag = max(0.001, binsize_plot_unit_mean_lag)
                    else: # seconds or mixed
                        binsize_plot_unit_mean_lag = max(1.0, binsize_plot_unit_mean_lag)
                    
                    if binsize_plot_unit_mean_lag >= 1: # Round if 1 or greater
                        binsize_plot_unit_mean_lag = round(binsize_plot_unit_mean_lag)
                    elif binsize_plot_unit_mean_lag >= 0.1: # Round to 1 decimal
                        binsize_plot_unit_mean_lag = round(binsize_plot_unit_mean_lag, 1)
                    elif binsize_plot_unit_mean_lag >= 0.01: # Round to 2 decimals
                        binsize_plot_unit_mean_lag = round(binsize_plot_unit_mean_lag, 2)
                    elif binsize_plot_unit_mean_lag >= 0.001: # Round to 3 decimals
                        binsize_plot_unit_mean_lag = round(binsize_plot_unit_mean_lag, 3)

                # Create bin edges starting from 0
                # Ensure max_val is included: bins should extend slightly beyond max_val.
                # If max_val and min_val are identical, ensure `bins` has at least two edges.
                if max_val == min_val:
                    bins = np.array([min_val, min_val + binsize_plot_unit_mean_lag])
                else:
                    bins = np.arange(0, max_val + binsize_plot_unit_mean_lag + 1e-9, binsize_plot_unit_mean_lag)
                
                # Assign data to bins and get counts
                # Ensure binned_data_series is not empty before value_counts()
                if not mean_lag_values_to_plot.empty:
                    binned_data_series = pd.cut(
                        mean_lag_values_to_plot,
                        bins=bins,
                        right=False, # [start, end)
                        include_lowest=True # Include 0 in the first bin
                    ).astype(str) # Convert to string for Plotly sorting

                    # Filter out 'NaN' bins (for data outside explicit bins)
                    binned_counts_df = binned_data_series.value_counts().reset_index()
                    binned_counts_df.columns = ['Bin_Range', 'Count']
                    
                    # Sort bins properly for visualization
                    binned_counts_df['Bin_Start_Sort'] = binned_counts_df['Bin_Range'].apply(lambda x: float(x.split(',')[0].replace('[', '')) if pd.notna(x) and '[' in x else -np.inf)
                    binned_counts_df = binned_counts_df.sort_values('Bin_Start_Sort').drop(columns='Bin_Start_Sort').reset_index(drop=True)

                    # --- CREATE PLOTLY EXPRESS BAR CHART (acting as a histogram) ---
                    fig_lag_hist = px.bar(
                        binned_counts_df,
                        x='Bin_Range',
                        y='Count',
                        labels={
                            'Bin_Range': f'Mean Lag ({time_format_option})', # Dynamic label
                            'Count': 'Number of DTs'
                        },
                        text='Count' # Display count on top of bars
                    )
                    fig_lag_hist.update_layout(bargap=0.1)

                    # --- X-axis formatting for histogram (no log scale here for this chart) ---
                    fig_lag_hist.update_xaxes(
                        categoryorder='array', # Ensure custom order
                        categoryarray=binned_counts_df['Bin_Range'].tolist(),
                        tickangle=0 # Force horizontal labels
                    )
                    fig_lag_hist.update_traces(textposition='outside') # Text on top of bars
                                
                    st.plotly_chart(fig_lag_hist, use_container_width=True)
                else: # mean_lag_values_to_plot is empty after binning
                    st.info("No mean lag data to display for histogram after unit conversion and binning.", icon="ℹ️")
            else: # mean_lag_values_to_plot is empty
                st.info("No mean lag data to display for histogram after unit conversion.", icon="ℹ️")
        else:
            st.info("No mean lag data to display for selected filters.", icon="ℹ️")


    with chart_detail_row1_cols[1]: # Tables by Last Completed Refresh Status (Bar Chart)
        st.markdown("<p style='font-size:16px;'><b>Tables by Last Completed Refresh Status</b></p>", unsafe_allow_html=True)
        st.write("Distribution of dynamic tables based on their most recent refresh outcome.")

        last_refresh_state_counts = final_filtered_metadata_df['LAST_COMPLETED_REFRESH_STATE'].value_counts().reset_index()
        last_refresh_state_counts.columns = ['Status', 'Count']

        if not last_refresh_state_counts.empty:
            fig_last_refresh_state = px.bar(
                last_refresh_state_counts,
                x='Count',
                y='Status',
                orientation='h',
                title='Last Completed Refresh Status',
                color='Status',
                color_discrete_map={'SUCCEEDED': 'green', 'FAILED': 'red', 'UPSTREAM_FAILED': 'darkred', 'CANCELLED': 'orange', 'UNKNOWN': 'grey'})
            
            status_order_for_bar = ['SUCCEEDED', 'FAILED', 'UPSTREAM_FAILED', 'CANCELLED', 'UNKNOWN']
            present_status_order = [s for s in status_order_for_bar if s in last_refresh_state_counts['Status'].tolist()]
            fig_last_refresh_state.update_yaxes(categoryorder="array", categoryarray=present_status_order[::-1])

            use_log_scale_last_refresh = st.checkbox("Log Scale X-axis (Last Refresh Status)", key="new_log_scale_last_refresh_dt_health")
            if use_log_scale_last_refresh:
                fig_last_refresh_state.update_xaxes(type='log')
                st.info("Logarithmic scale applied to X-axis.", icon="ℹ️")

            st.plotly_chart(fig_last_refresh_state, use_container_width=True)
        else:
            st.info("No last refresh status data to display for selected filters.", icon="ℹ️")

    st.divider()

    # --- New Chart: Time Within Target Lag Ratio Distribution (Histogram) ---
    st.markdown("<p style='font-size:16px;'><b>Time Within Target Lag Ratio Distribution</b></p>", unsafe_allow_html=True)
    st.write("Distribution of dynamic tables based on how often their actual lag is within the target lag (0-100%).")
    
    lag_ratio_data = final_filtered_metadata_df['TIME_WITHIN_TARGET_LAG_RATIO'].dropna()
    
    if not lag_ratio_data.empty:
        lag_ratio_data_pct = lag_ratio_data * 100
        
        fig_lag_ratio_hist = px.histogram(
            lag_ratio_data_pct, 
            x="TIME_WITHIN_TARGET_LAG_RATIO", 
            nbins=10,
            title='Time Within Target Lag Ratio Distribution',
            labels={'TIME_WITHIN_TARGET_LAG_RATIO': 'Ratio (%)'},
            range_x=[0, 100]
        )
        fig_lag_ratio_hist.update_layout(bargap=0.1)
        st.plotly_chart(fig_lag_ratio_hist, use_container_width=True)
    else:
        st.info("No 'Time Within Target Lag Ratio' data to display for selected filters.", icon="ℹ️")
        
    st.divider()


    # --- Detailed Dynamic Table Current Status Table with Show/Hide ---
    st.subheader("Detailed Dynamic Table Status")
    
    # Radio buttons for conditional formatting
    color_by_option = st.radio(
        "Color Table By:",
        ('None', 'Status', 'Mean Lag', 'Max Lag', 'Time Above Target Lag', 'Lag Ratio'),
        index=0,
        horizontal=True,
        key="new_color_by_dt_health_table"
    )

    st.write("Detailed metadata and lag metrics for each dynamic table based on latest snapshot.")

    if final_filtered_metadata_df.empty:
        st.info("No detailed dynamic table status to display based on current filters.", icon="ℹ️")
        return

    # Use a copy for display formatting
    df_for_display = final_filtered_metadata_df.copy()
    
    # Define thresholds for coloring based on typical values (adjust these to your needs!)
    thresholds = {
        'mean_lag': {'ok': 300, 'warning': 1800, 'critical': 3600}, # 5min, 30min, 1hr in seconds
        'max_lag': {'ok': 600, 'warning': 3600, 'critical': 7200}, # 10min, 1hr, 2hr in seconds
        'time_above': {'ok': 0, 'warning': 300, 'critical': 1800}, # 0, 5min, 30min in seconds
        'lag_ratio': {'ok': 0.90, 'warning': 0.70, 'critical': 0.01} # 90%, 70%, 1%
    }

    # Apply formatting for display to new columns
    df_for_display['TARGET_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['TARGET_LAG_SEC'], time_format_option)
    df_for_display['MEAN_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['MEAN_LAG_SEC'], time_format_option)
    df_for_display['MAXIMUM_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['MAXIMUM_LAG_SEC'], time_format_option)
    df_for_display['TIME_ABOVE_TARGET_LAG_SEC_FMT'] = format_seconds_to_readable(df_for_display['TIME_ABOVE_TARGET_LAG_SEC'], time_format_option)
    df_for_display['TIME_WITHIN_TARGET_LAG_RATIO_FMT'] = (df_for_display['TIME_WITHIN_TARGET_LAG_RATIO'] * 100).round(1).astype(str) + '%'


    # Define display columns and their labels (QUALIFIED_NAME is correctly handled)
    dt_health_display_columns_order = [
        'QUALIFIED_NAME',
        'SCHEDULING_STATE_STATUS', 'SCHEDULING_STATE_REASON_MESSAGE', 
        'TARGET_LAG_SEC_FMT', 'MEAN_LAG_SEC_FMT', 'MAXIMUM_LAG_SEC_FMT',
        'TIME_ABOVE_TARGET_LAG_SEC_FMT', 'TIME_WITHIN_TARGET_LAG_RATIO_FMT', 
        'LATEST_DATA_TIMESTAMP', 'LAST_COMPLETED_REFRESH_STATE', 'EXECUTING_REFRESH_QUERY_ID',
        'COLLECTION_TIMESTAMP'
    ]
    
    dt_health_display_labels = {
        'QUALIFIED_NAME': 'Dynamic Table',
        'SCHEDULING_STATE_STATUS': 'Status',
        'SCHEDULING_STATE_REASON_MESSAGE': 'Reason',
        'TARGET_LAG_SEC_FMT': 'Target Lag',
        'MEAN_LAG_SEC_FMT': 'Mean Lag',
        'MAXIMUM_LAG_SEC_FMT': 'Max Lag',
        'TIME_ABOVE_TARGET_LAG_SEC_FMT': 'Time Above Lag',
        'TIME_WITHIN_TARGET_LAG_RATIO_FMT': 'Lag Ratio (%)',
        'LATEST_DATA_TIMESTAMP': 'Latest Data Time',
        'LAST_COMPLETED_REFRESH_STATE': 'Last Refresh Status',
        'EXECUTING_REFRESH_QUERY_ID': 'Executing Query ID',
        'COLLECTION_TIMESTAMP': 'Snapshot Time'
    }

    # Select and rename columns for the display DataFrame
    df_for_display = df_for_display[[col for col in dt_health_display_columns_order if col in df_for_display.columns]].rename(columns=dt_health_display_labels)


    # --- Apply Sorting ---
    final_df_for_display_sorted = df_for_display.copy()

    # Determine sorting criteria
    original_sort_column_map = {
        'Status': 'SCHEDULING_STATE_STATUS',
        'Mean Lag': 'MEAN_LAG_SEC',
        'Max Lag': 'MAXIMUM_LAG_SEC',
        'Time Above Target Lag': 'TIME_ABOVE_TARGET_LAG_SEC',
        'Lag Ratio': 'TIME_WITHIN_TARGET_LAG_RATIO'
    }
    
    sort_column_original_name = original_sort_column_map.get(color_by_option)

    if sort_column_original_name:
        if sort_column_original_name != 'SCHEDULING_STATE_STATUS': # Sort numeric columns
            ascending = True if color_by_option == 'Lag Ratio' else False
            
            # CRITICAL FIX FOR SORTING:
            # We need to sort based on the original numeric values from final_filtered_metadata_df
            # then use that sorted order to reindex final_df_for_display_sorted.
            sort_order_index = final_filtered_metadata_df.sort_values(
                by=sort_column_original_name, ascending=ascending
            ).index
            final_df_for_display_sorted = final_df_for_display_sorted.loc[sort_order_index].reset_index(drop=True)
            
        else: # Custom sort for 'Status' column (SCHEDULING_STATE_STATUS) based on severity
            status_severity_order = {
                'SUSPENDED': 0, # Highest severity
                'FAILED': 1,
                'UPSTREAM_FAILED': 2,
                'CANCELLED': 3,
                'WARNING': 4,
                'RUNNING': 5,
                'SUCCEEDED': 6,
                'UNKNOWN': 7
            }
            # Add temp sort keys to final_df_for_display_sorted for sorting
            final_df_for_display_sorted['Temp_Sort_Key'] = final_filtered_metadata_df['SCHEDULING_STATE_STATUS'].map(status_severity_order).fillna(999)
            final_df_for_display_sorted['Temp_Last_Refresh_Sort_Key'] = final_filtered_metadata_df['LAST_COMPLETED_REFRESH_STATE'].map({
                'FAILED': 0, 'UPSTREAM_FAILED': 1, 'CANCELLED': 2, 'WARNING': 3, 'SUCCEEDED': 4, 'UNKNOWN': 5
            }).fillna(999)

            final_df_for_display_sorted = final_df_for_display_sorted.sort_values(
                by=['Temp_Sort_Key', 'Temp_Last_Refresh_Sort_Key'], ascending=[True, True]
            ).drop(columns=['Temp_Sort_Key', 'Temp_Last_Refresh_Sort_Key']).reset_index(drop=True)


    # --- Apply Styling (row-wise background color) ---
    if color_by_option != 'None':
        # Apply the row style using apply_row_style function
        # The lambda now passes the correct row from final_filtered_metadata_df
        # to ensure original numeric values are used for thresholds.
        # It also explicitly passes the display column names.
        styled_df = final_df_for_display_sorted.style.apply(
            lambda row_display: apply_row_style(
                # Get the corresponding row from the ORIGINAL final_filtered_metadata_df
                # Use the 'Dynamic Table' column (which holds original QUALIFIED_NAME) to find it.
                final_filtered_metadata_df[final_filtered_metadata_df['QUALIFIED_NAME'] == row_display['Dynamic Table']].iloc[0],
                final_df_for_display_sorted.columns, # Pass the display column names
                color_by_option,
                thresholds
            ), 
            axis=1 # Apply row-wise
        )
        st.dataframe(
            styled_df,
            use_container_width=True
        )
    else: # Render without styling
        st.dataframe(
            final_df_for_display_sorted, # Display the sorted df without styling
            use_container_width=True
        )

    st.markdown("---")
    st.write("### Interpretation:")
    st.markdown("""
- **Row Coloring (controlled by 'Color Table By' radio button):**
    - **Green**: Healthy (e.g., SUCCEEDED refresh, very low lag, high lag ratio).
    - **Orange**: Warning (e.g., WARNING refresh, moderate lag, medium lag ratio, running with issues).
    - **Red**: Critical (e.g., FAILED refresh, very high lag, low lag ratio).
    - **Blue**: Suspended status.
- **Sorting (updates with 'Color Table By' selection):**
    - Tables are sorted from highest severity to lowest severity based on the chosen metric.
    """)
