# tabs/dt_health_tab.py
import streamlit as st
import pandas as pd
import plotly.express as px
from datetime import datetime, timedelta

# --- Helper functions (from previous code) ---
def format_seconds_to_readable(seconds_series, format_type):
    if not isinstance(seconds_series, pd.Series):
        seconds_series = pd.Series([seconds_series])
    numeric_series = pd.to_numeric(seconds_series, errors='coerce')
    if numeric_series.empty or pd.isna(numeric_series).all():
        return pd.Series(["N/A"] * len(numeric_series), index=numeric_series.index)
    def format_single_second(s, f_type):
        if pd.isna(s): return "N/A"
        s = float(s)
        if s == 0: return "0s"
        if f_type == "seconds": return f"{s:.1f}s"
        elif f_type == "minutes": return f"{(s / 60):.1f}m"
        elif f_type == "hours": return f"{(s / 3600):.1f}h"
        elif f_type == "days": return f"{(s / 86400):.1f}d"
        elif f_type == "mixed":
            days = int(s // 86400); s_remaining = s % 86400
            hours = int(s_remaining // 3600); s_remaining = s_remaining % 3600
            minutes = int(s_remaining // 60); seconds = s_remaining % 60
            parts = []
            if days > 0: parts.append(f"{days}d")
            if hours > 0: parts.append(f"{hours}h")
            if minutes > 0: parts.append(f"{minutes}m")
            if seconds > 0.1 and (not parts or seconds >= 1): parts.append(f"{seconds:.1f}s")
            return " ".join(parts) if parts else "0s"
        return str(s)
    return numeric_series.apply(lambda x: format_single_second(x, f_type=format_type))

# --- Data Fetching Functions ---

@st.cache_data(ttl=(12*60*60))
def fetch_driver_execution_history_summary():
    session = st.session_state.get_snowflake_session()
    AUDIT_LOG_TABLE_FQDN = "YOUR_DB.YOUR_SCHEMA.T_DT_COLLECTION_AUDIT_LOG"
    query = f"""
    SELECT
        DRIVER_RUN_UUID, RUN_STATUS, RUN_START_TIME, RUN_END_TIME,
        TOTAL_DURATION_SEC, TOTAL_TABLES_FOUND, TOTAL_JOBS_LAUNCHED,
        TOTAL_ASYNC_JOBS_SUCCEEDED, TOTAL_ASYNC_JOBS_FAILED,
        MESSAGE AS RUN_MESSAGE, TIMEZONE
    FROM {AUDIT_LOG_TABLE_FQDN}
    WHERE RUN_START_TIME >= DATEADD(day, -30, CURRENT_TIMESTAMP())
    ORDER BY RUN_START_TIME DESC
    """
    df = session.sql(query).to_pandas()
    if not df.empty:
        df['RUN_START_TIME'] = pd.to_datetime(df['RUN_START_TIME'])
        df['RUN_END_TIME'] = pd.to_datetime(df['RUN_END_TIME'])
    return df

@st.cache_data(ttl=(5*60))
def fetch_dt_tracking_data():
    session = st.session_state.get_snowflake_session()
    TRACKING_TABLE_FQDN = "YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_TRACKING"
    METADATA_SNAPSHOT_TABLE_FQDN = "YOUR_DB.YOUR_SCHEMA.T_DYNAMIC_TABLE_METADATA_LATEST_SNAPSHOT"

    query = f"""
    SELECT
        t.QUALIFIED_NAME,
        t.DATABASE_NAME,
        t.SCHEMA_NAME,
        t.TABLE_NAME,
        t.DOMAIN_NAME,
        t.SUB_DOMAIN_NAME,
        t.IS_ACTIVE,
        t.TRACK_REFRESH_HISTORY,
        t.LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP,
        t.LAST_REFRESH_HISTORY_COLLECTION_STATUS,
        t.LAST_REFRESH_HISTORY_COLLECTION_MESSAGE,
        t.TRACK_METADATA_SNAPSHOT,
        t.LAST_METADATA_COLLECTION_TIMESTAMP,
        t.LAST_METADATA_COLLECTION_STATUS,
        t.LAST_METADATA_COLLECTION_MESSAGE,
        ms.LATEST_DATA_TIMESTAMP,
        ms.MEAN_LAG_SEC,
        ms.MAXIMUM_LAG_SEC,
        ms.TARGET_LAG_SEC,
        t.UPDATED_AT
    FROM
        {TRACKING_TABLE_FQDN} AS t
    LEFT JOIN
        {METADATA_SNAPSHOT_TABLE_FQDN} AS ms
    ON
        t.QUALIFIED_NAME = ms.QUALIFIED_NAME
    ORDER BY
        t.QUALIFIED_NAME
    """
    df = session.sql(query).to_pandas()
    if not df.empty:
        df['LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP'] = pd.to_datetime(df['LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP'])
        df['LAST_METADATA_COLLECTION_TIMESTAMP'] = pd.to_datetime(df['LAST_METADATA_COLLECTION_TIMESTAMP'])
        df['LATEST_DATA_TIMESTAMP'] = pd.to_datetime(df['LATEST_DATA_TIMESTAMP'])
        df['UPDATED_AT'] = pd.to_datetime(df['UPDATED_AT'])
    return df


# --- Helper to manage widget state persistence (RE-INTEGRATED for local filters) ---
# NOTE: These helpers are now specifically for LOCAL filters within this tab.
def persist_local_widget_state(key_prefix):
    temp_key = f"_{key_prefix}"
    perm_key = key_prefix
    if temp_key in st.session_state:
        st.session_state[perm_key] = st.session_state[temp_key]

def load_local_widget_state(key_prefix, default_value):
    perm_key = key_prefix
    temp_key = f"_{key_prefix}"
    if perm_key not in st.session_state:
        st.session_state[perm_key] = default_value
    st.session_state[temp_key] = st.session_state[perm_key]
    return st.session_state[perm_key]


# --- Main Render Function for the DT Health Tab ---
def render_dt_health_tab():
    st.header("Dynamic Table Health Dashboard")
    st.write("Overview of driver execution, collection status, and detailed table health.")

    # --- 1. Fetch Data ---
    driver_history_df = fetch_driver_execution_history_summary()
    all_tracking_data_df = fetch_dt_tracking_data() # Fetches all data initially

    if all_tracking_data_df.empty:
        st.info("No data available from tracking tables. Please check data sources.", icon="ℹ️")
        return
    
    # --- Apply GLOBAL Filters (First Level of Filtering) from session_state ---
    # These values are set by filter_canvas.py (if used) or default to 'All'
    globally_filtered_tracking_data_df = all_tracking_data_df.copy()

    global_domain_name = st.session_state.get('global_domain_name', 'All')
    global_sub_domain_name = st.session_state.get('global_sub_domain_name', 'All')
    global_db_filter = st.session_state.get('global_db_filter', 'All')
    global_schema_filter = st.session_state.get('global_schema_filter', 'All')
    global_table_filter = st.session_state.get('global_table_filter', ['All'])
    global_scheduling_state_filter = st.session_state.get('global_scheduling_state_filter', ['All'])
    global_target_lag_filter = st.session_state.get('global_target_lag', ['All'])
    display_lag_times_in = st.session_state.get('display_lag_times_in', 'mixed') # Display format option from global
    global_is_active_filter = st.session_state.get('global_is_active_filter', 'All')

    # Apply global filters in their dependency order to the DataFrame
    if global_domain_name != 'All':
        globally_filtered_tracking_data_df = globally_filtered_tracking_data_df[globally_filtered_tracking_data_df['DOMAIN_NAME'] == global_domain_name]
    if global_sub_domain_name != 'All':
        globally_filtered_tracking_data_df = globally_filtered_tracking_data_df[globally_filtered_tracking_data_df['SUB_DOMAIN_NAME'] == global_sub_domain_name]
    if global_db_filter != 'All':
        globally_filtered_tracking_data_df = globally_filtered_tracking_data_df[globally_filtered_tracking_data_df['DATABASE_NAME'] == global_db_filter]
    if global_schema_filter != 'All':
        globally_filtered_tracking_data_df = globally_filtered_tracking_data_df[globally_filtered_tracking_data_df['SCHEMA_NAME'] == global_schema_filter]
    if 'All' not in global_table_filter:
        globally_filtered_tracking_data_df = globally_filtered_tracking_data_df[globally_filtered_tracking_data_df['TABLE_NAME'].isin(global_table_filter)]
    if 'All' not in global_scheduling_state_filter:
        globally_filtered_tracking_data_df = globally_filtered_tracking_data_df[globally_filtered_tracking_data_df['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].isin(global_scheduling_state_filter)]
    if 'All' not in global_target_lag_filter:
        target_lag_values_for_filter_numeric = [int(s.replace('s', '')) for s in global_target_lag_filter]
        globally_filtered_tracking_data_df = globally_filtered_tracking_data_df[globally_filtered_tracking_data_df['TARGET_LAG_SEC'].isin(target_lag_values_for_filter_numeric)]
    if global_is_active_filter != 'All':
        globally_filtered_tracking_data_df = globally_filtered_tracking_data_df[globally_filtered_tracking_data_df['IS_ACTIVE'] == global_is_active_filter]
    

    if globally_filtered_tracking_data_df.empty:
        st.info("No data available based on the current Global Filter Canvas selections. Please adjust your global filters.", icon="ℹ️")
        return


    # --- Local Filters (Second Level of Filtering) for this tab's specific UI ---
    st.markdown("---")
    st.subheader("Apply Filters for DT Health (Local)")

    # Load initial filter states for LOCAL filters using the persistence helpers
    # These keys are specific to this tab (e.g., 'dt_health_tab_db_filter')
    current_local_db_filter = load_local_widget_state('dt_health_tab_db_filter', 'All')
    current_local_schema_filter = load_local_widget_state('dt_health_tab_schema_filter', 'All')
    current_local_table_filter = load_local_widget_state('dt_health_tab_table_filter', ['All'])
    current_local_scheduling_state_filter = load_local_widget_state('dt_health_tab_scheduling_state_filter', ['All'])
    current_local_target_lag_filter = load_local_widget_state('dt_health_tab_target_lag_filter', ['All'])
    current_local_domain_name_filter = load_local_widget_state('dt_health_tab_domain_name_filter', 'All')
    current_local_sub_domain_name_filter = load_local_widget_state('dt_health_tab_sub_domain_name_filter', 'All')
    current_local_display_lag_times_in = load_local_widget_state('dt_health_tab_display_lag_times_in', 'mixed') # Radio button

    # Columns for local filters - matching screenshot layout
    filter_cols_row1 = st.columns(4) # Database, Schema, Table(s), Scheduling State(s)
    filter_cols_row2 = st.columns(4) # Domain Name, Sub Domain Name, Target Lag (seconds), Display Lag Times In

    # Use the GLOBALLY filtered data (globally_filtered_tracking_data_df)
    # as the source for options for these local widgets.
    local_options_base_df = globally_filtered_tracking_data_df.copy()

    # --- Row 1 Filters (top to bottom): Domain, Sub Domain, Database, Schema, Table ---
    # Order matters for options generation: Domain -> Sub Domain -> Database -> Schema -> Table
    # The actual widget placement below will follow the screenshot order (DB first)

    # To manage cascading across the screenshot's row layout (DB on row1, Domain on row2),
    # we need to ensure the options are filtered based on the *parent's selection* regardless of rendering order.
    # We will compute the `_options_base_for_next_level` DFs in sequence,
    # and then assign to the actual widget.

    # 1. Filtered by Domain Name (from Row 2, but computed first as it's a higher parent)
    options_after_domain = local_options_base_df.copy()
    if current_local_domain_name_filter != 'All':
        options_after_domain = options_after_domain[options_after_domain['DOMAIN_NAME'] == current_local_domain_name_filter]

    # 2. Filtered by Sub Domain Name (from Row 2, depends on Domain)
    options_after_sub_domain = options_after_domain.copy()
    if current_local_sub_domain_name_filter != 'All':
        options_after_sub_domain = options_after_sub_domain[options_after_sub_domain['SUB_DOMAIN_NAME'] == current_local_sub_domain_name_filter]
    
    # 3. Filtered by Database (from Row 1, depends on Sub Domain)
    options_after_database = options_after_sub_domain.copy()
    if current_local_db_filter != 'All':
        options_after_database = options_after_database[options_after_database['DATABASE_NAME'] == current_local_db_filter]

    # 4. Filtered by Schema (from Row 1, depends on Database)
    options_after_schema = options_after_database.copy()
    if current_local_schema_filter != 'All':
        options_after_schema = options_after_schema[options_after_schema['SCHEMA_NAME'] == current_local_schema_filter]
    
    # 5. Filtered by Table (from Row 1, depends on Schema)
    options_after_table = options_after_schema.copy()
    # (table selection is handled directly, not for cascading other options here)


    # --- Render Widgets (Order based on Screenshot Layout) ---

    # --- Row 1: Database, Schema, Table(s), Scheduling State(s) ---
    with filter_cols_row1[0]: # Database
        all_databases = ['All'] + sorted(options_after_sub_domain['DATABASE_NAME'].unique().tolist())
        if current_local_db_filter not in all_databases:
            current_local_db_filter = 'All'; st.session_state.dt_health_tab_db_filter = 'All'
        db_index = all_databases.index(current_local_db_filter)
        selected_db = st.selectbox("Database:", options=all_databases, key="_dt_health_tab_db_filter", index=db_index, on_change=persist_local_widget_state, args=("dt_health_tab_db_filter",))
        current_local_db_filter = selected_db # Update live filter for dependent widgets


    with filter_cols_row1[1]: # Schema
        all_schemas = ['All'] + sorted(options_after_database['SCHEMA_NAME'].unique().tolist())
        if current_local_schema_filter not in all_schemas:
            current_local_schema_filter = 'All'; st.session_state.dt_health_tab_schema_filter = 'All'
        schema_index = all_schemas.index(current_local_schema_filter)
        selected_schema = st.selectbox("Schema:", options=all_schemas, key="_dt_health_tab_schema_filter", index=schema_index, on_change=persist_local_widget_state, args=("dt_health_tab_schema_filter",))
        current_local_schema_filter = selected_schema


    with filter_cols_row1[2]: # Table(s)
        all_tables = ['All'] + sorted(options_after_schema['TABLE_NAME'].unique().tolist())
        valid_current_tables = [t for t in current_local_table_filter if t in all_tables]
        if not valid_current_tables and 'All' in all_tables:
             valid_current_tables = ['All']; st.session_state.dt_health_tab_table_filter = ['All']
        elif not valid_current_tables: valid_current_tables = []; st.session_state.dt_health_tab_table_filter = []
        selected_tables = st.multiselect("Table(s):", options=all_tables, key="_dt_health_tab_table_filter", default=valid_current_tables, on_change=persist_local_widget_state, args=("dt_health_tab_table_filter",))
        current_local_table_filter = selected_tables


    with filter_cols_row1[3]: # Scheduling State(s)
        # This filter is independent in the options generation, so it uses `all_tracking_data_df` directly.
        all_scheduling_states = ['All'] + sorted(all_tracking_data_df['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].unique().tolist())
        valid_current_sched_states = [s for s in current_local_scheduling_state_filter if s in all_scheduling_states]
        if not valid_current_sched_states and 'All' in all_scheduling_states:
             valid_current_sched_states = ['All']; st.session_state.dt_health_tab_scheduling_state_filter = ['All']
        selected_sched_state = st.multiselect("Scheduling State(s):", options=all_scheduling_states, key="_dt_health_tab_scheduling_state_filter", default=valid_current_sched_states, on_change=persist_local_widget_state, args=("dt_health_tab_scheduling_state_filter",))
        current_local_scheduling_state_filter = selected_sched_state


    # --- Row 2: Domain Name, Sub Domain Name, Target Lag (seconds), Display Lag Times In ---
    with filter_cols_row2[0]: # Domain Name
        all_domains = ['All'] + sorted(all_tracking_data_df['DOMAIN_NAME'].unique().tolist())
        domain_index = all_domains.index(current_local_domain_name_filter) if current_local_domain_name_filter in all_domains else 0
        selected_domain = st.selectbox("Domain Name:", options=all_domains, key="_dt_health_tab_domain_name_filter", index=domain_index, on_change=persist_local_widget_state, args=("dt_health_tab_domain_name_filter",))
        current_local_domain_name_filter = selected_domain


    with filter_cols_row2[1]: # Sub Domain Name (depends on Domain Name)
        all_sub_domains = ['All'] + sorted(options_after_domain['SUB_DOMAIN_NAME'].dropna().unique().tolist())
        if current_local_sub_domain_name_filter not in all_sub_domains:
            current_local_sub_domain_name_filter = 'All'; st.session_state.dt_health_tab_sub_domain_name_filter = 'All'
        sub_domain_index = all_sub_domains.index(current_local_sub_domain_name_filter) if current_local_sub_domain_name_filter in all_sub_domains else 0
        selected_sub_domain = st.selectbox("Sub Domain Name:", options=all_sub_domains, key="_dt_health_tab_sub_domain_name_filter", index=sub_domain_index, on_change=persist_local_widget_state, args=("dt_health_tab_sub_domain_name_filter",))
        current_local_sub_domain_name_filter = selected_sub_domain

    with filter_cols_row2[2]: # Target Lag (seconds)
        # Note: This is an independent filter, so its options come from all_tracking_data_df directly.
        all_target_lags_raw = all_tracking_data_df['TARGET_LAG_SEC'].dropna().unique().tolist()
        all_target_lags_formatted = sorted([f"{int(x)}s" for x in all_target_lags_raw])
        all_target_lags_options = ['All'] + all_target_lags_formatted
        
        valid_current_target_lags = [l for l in current_local_target_lag_filter if l in all_target_lags_options]
        if not valid_current_target_lags and 'All' in all_target_lags_options:
             valid_current_target_lags = ['All']; st.session_state.dt_health_tab_target_lag_filter = ['All']
        elif not valid_current_target_lags: valid_current_target_lags = []; st.session_state.dt_health_tab_target_lag_filter = []

        selected_target_lag = st.multiselect("Target Lag (seconds):", options=all_target_lags_options, key="_dt_health_tab_target_lag_filter", default=valid_current_target_lags, on_change=persist_local_widget_state, args=("dt_health_tab_target_lag_filter",))
        current_local_target_lag_filter = selected_target_lag


    with filter_cols_row2[3]: # Display Lag Times In
        all_time_formats = ["mixed", "seconds", "minutes", "hours", "days"]
        time_format_index = all_time_formats.index(current_local_display_lag_times_in) if current_local_display_lag_times_in in all_time_formats else 0
        selected_time_format = st.radio("Display Lag Times In:", options=all_time_formats, index=time_format_index, horizontal=True, key="_dt_health_tab_display_lag_times_in", on_change=persist_local_widget_state, args=("dt_health_tab_display_lag_times_in",))
        current_local_display_lag_times_in = selected_time_format


    st.markdown("---")


    # --- Apply ALL Filters (Global + Local) to initial all_tracking_data_df ---
    # This `final_filtered_data_for_display` will be the base for all KPIs, Charts, and the Detailed Table
    final_filtered_data_for_display = all_tracking_data_df.copy()

    # Apply GLOBAL filters first (read from session_state)
    global_domain_name_filter = st.session_state.get('global_domain_name', 'All')
    global_sub_domain_name_filter = st.session_state.get('global_sub_domain_name', 'All')
    global_db_filter = st.session_state.get('global_db_filter', 'All')
    global_schema_filter = st.session_state.get('global_schema_filter', 'All')
    global_table_filter = st.session_state.get('global_table_filter', ['All'])
    global_scheduling_state_filter = st.session_state.get('global_scheduling_state_filter', ['All'])
    global_target_lag_filter = st.session_state.get('global_target_lag', ['All'])
    global_is_active_filter = st.session_state.get('global_is_active_filter', 'All')


    if global_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DOMAIN_NAME'] == global_domain_name_filter]
    if global_sub_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SUB_DOMAIN_NAME'] == global_sub_domain_name_filter]
    if global_db_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DATABASE_NAME'] == global_db_filter]
    if global_schema_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SCHEMA_NAME'] == global_schema_filter]
    if 'All' not in global_table_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TABLE_NAME'].isin(global_table_filter)]
    if 'All' not in global_scheduling_state_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].isin(global_scheduling_state_filter)]
    if 'All' not in global_target_lag_filter:
        global_target_lag_values_numeric = [int(s.replace('s', '')) for s in global_target_lag_filter]
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TARGET_LAG_SEC'].isin(global_target_lag_values_numeric)]
    if global_is_active_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['IS_ACTIVE'] == global_is_active_filter]
    
    # Apply LOCAL filters (read from this tab's session_state keys)
    # Apply to the globally filtered data.
    if current_local_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DOMAIN_NAME'] == current_local_domain_name_filter]
    if current_local_sub_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SUB_DOMAIN_NAME'] == current_local_sub_domain_name_filter]
    if current_local_db_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DATABASE_NAME'] == current_local_db_filter]
    if current_local_schema_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SCHEMA_NAME'] == current_local_schema_filter]
    if 'All' not in current_local_table_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TABLE_NAME'].isin(current_local_table_filter)]
    if 'All' not in current_local_scheduling_state_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].isin(current_local_scheduling_state_filter)]
    if 'All' not in current_local_target_lag_filter:
        local_target_lag_values_numeric = [int(s.replace('s', '')) for s in current_local_target_lag_filter]
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TARGET_LAG_SEC'].isin(local_target_lag_values_numeric)]


    # If no data left after all filters, inform the user
    if final_filtered_data_for_display.empty:
        st.info("No tables match the combined global and local filter selections.", icon="ℹ️")
        return

    # Update tracking_data_df to be the final filtered one for KPIs and Charts
    tracking_data_df = final_filtered_data_for_display.copy()


    # --- 2. Overall Driver Health KPIs ---
    st.subheader("Overall Driver Health KPIs")
    kpi_cols = st.columns(4)

    latest_run = driver_history_df.iloc[0] if not driver_history_df.empty else None
    
    total_tables_tracked = tracking_data_df['QUALIFIED_NAME'].nunique() if not tracking_data_df.empty else 0
    active_rh_tracking = tracking_data_df[
        (tracking_data_df['IS_ACTIVE'] == True) & (tracking_data_df['TRACK_REFRESH_HISTORY'] == True)
    ].shape[0] if not tracking_data_df.empty else 0
    active_metadata_tracking = tracking_data_df[
        (tracking_data_df['IS_ACTIVE'] == True) & (tracking_data_df['TRACK_METADATA_SNAPSHOT'] == True)
    ].shape[0] if not tracking_data_df.empty else 0
    
    tables_not_refreshed_last_3_days = 0
    if not tracking_data_df.empty and 'LATEST_DATA_TIMESTAMP' in tracking_data_df.columns:
        three_days_ago = datetime.now() - timedelta(days=3)
        tables_not_refreshed_last_3_days = tracking_data_df[
            (tracking_data_df['LATEST_DATA_TIMESTAMP'].isna()) |
            (tracking_data_df['LATEST_DATA_TIMESTAMP'] < three_days_ago)
        ].shape[0]

    with kpi_cols[0]:
        st.metric("Total Tables Tracked", total_tables_tracked)
        st.metric("Active (RH) Tracking", active_rh_tracking)
    with kpi_cols[1]:
        st.metric("Active Tables Monitored", total_tables_tracked)
        st.metric("Active (Metadata) Tracking", active_metadata_tracking)
    with kpi_cols[2]:
        if latest_run is not None:
            st.metric("Last Driver Run Time", latest_run['RUN_END_TIME'].strftime('%Y-%m-%d %H:%M:%S'))
        else:
            st.metric("Last Driver Run Time", "N/A")
        st.metric("Tables Not Refreshed (last 3d)", tables_not_refreshed_last_3_days)
    with kpi_cols[3]:
        if latest_run is not None:
            duration_formatted = format_seconds_to_readable(
                pd.Series([latest_run['TOTAL_DURATION_SEC']]), "mixed"
            ).iloc[0]
            st.metric("Last Run Duration", duration_formatted)
        else:
            st.metric("Last Run Duration", "N/A")

    st.markdown("---")

    # --- 3. Driver Execution Time Trend Chart and Collection Status Distribution ---
    chart_row_cols = st.columns([0.6, 0.4])

    with chart_row_cols[0]: # Driver Execution Time Trend Chart (Left)
        st.subheader("Driver Execution Time Trend")
        st.write("Historical execution times of the main collection driver program.")
        if not driver_history_df.empty:
            driver_history_chart_data = driver_history_df.copy()
            driver_history_chart_data.rename(columns={
                'RUN_START_TIME': 'Run Time',
                'TOTAL_DURATION_SEC': 'Duration (seconds)'
            }, inplace=True)

            log_scale_y = st.checkbox("Log Scale Y-axis (Driver Trend)", value=False, key="log_scale_driver_trend")
            
            fig_trend = px.line(
                driver_history_chart_data,
                x='Run Time',
                y='Duration (seconds)',
                title='Driver Program Execution Duration Over Time',
                markers=True,
                log_y=log_scale_y
            )
            fig_trend.update_layout(hovermode="x unified")
            st.plotly_chart(fig_trend, use_container_width=True)
        else:
            st.info("No historical driver execution data for trend chart.", icon="ℹ️")

    with chart_row_cols[1]: # Collection Status Distribution (Right)
        st.subheader("Collection Status Distribution")
        st.write("Breakdown of tables by their last collection status for each type.")
        if not tracking_data_df.empty:
            rh_status_counts = tracking_data_df['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].value_counts().reset_index()
            rh_status_counts.columns = ['Status', 'Count']
            rh_status_counts['Collection Type'] = 'Refresh History'

            md_status_counts = tracking_data_df['LAST_METADATA_COLLECTION_STATUS'].value_counts().reset_index()
            md_status_counts.columns = ['Status', 'Count']
            md_status_counts['Collection Type'] = 'Metadata Snapshot'

            combined_status_counts = pd.concat([rh_status_counts, md_status_counts])

            status_color_map_for_chart = {
                'SUCCESS': 'green',
                'SUCCESS_NO_RECORDS': 'lightgreen',
                'FAILED': 'red',
                'FAILED_EXECUTION': 'red',
                'FAILED_INPUT': 'red',
                'FAILED_SUBMISSION': 'red',
                'SUSPENDED': 'orange',
                'UNKNOWN': 'gray',
                'N/A': 'lightgray'
            }

            fig_bar = px.bar(
                combined_status_counts,
                x='Count',
                y='Collection Type',
                color='Status',
                orientation='h',
                title='Last Collection Status by Type',
                color_discrete_map=status_color_map_for_chart,
                text='Count'
            )
            fig_bar.update_traces(textposition='outside')
            fig_bar.update_layout(showlegend=True, yaxis_title=None, xaxis_title='Number of Tables')
            st.plotly_chart(fig_bar, use_container_width=True)
        else:
            st.info("No detailed tracking data for status distribution.", icon="ℹ️")
    
    st.markdown("---")

    # --- 4. Detailed Collection Status per Table (with local filtering) ---
    st.subheader("Detailed Collection Status per Table")
    st.write("View the last collection attempt status and messages for each dynamic table being tracked.")

    # Local filter options are derived from the already globally-filtered tracking_data_df
    local_options_for_this_tab = tracking_data_df.copy() # Use this DF to populate local filter options

    if local_options_for_this_tab.empty:
        st.info("No detailed collection status per table available.", icon="ℹ️")
        return

    # Filter section for local filters
    filter_cols_row1_local = st.columns(4) # Database, Schema, Table(s), Scheduling State(s)
    filter_cols_row2_local = st.columns(4) # Domain Name, Sub Domain Name, Target Lag (seconds), Display Lag Times In

    # --- Row 1 (Local): Database, Schema, Table(s), Scheduling State(s) ---
    with filter_cols_row1_local[0]: # Database
        all_databases_local = ['All'] + sorted(local_options_for_this_tab['DATABASE_NAME'].unique().tolist())
        selected_db_local = load_local_widget_state('dt_health_tab_db_filter', 'All')
        db_index_local = all_databases_local.index(selected_db_local) if selected_db_local in all_databases_local else 0
        selected_db_local = st.selectbox("Database:", options=all_databases_local, key="_dt_health_tab_db_filter", index=db_index_local, on_change=persist_local_widget_state, args=("dt_health_tab_db_filter",))
        # Update current for cascading
        current_db_filter_local = selected_db_local

    with filter_cols_row1_local[1]: # Schema (depends on Database)
        schema_options_df_local = local_options_for_this_tab.copy()
        if current_db_filter_local != 'All':
            schema_options_df_local = schema_options_df_local[schema_options_df_local['DATABASE_NAME'] == current_db_filter_local]
        all_schemas_local = ['All'] + sorted(schema_options_df_local['SCHEMA_NAME'].unique().tolist())
        selected_schema_local = load_local_widget_state('dt_health_tab_schema_filter', 'All')
        if selected_schema_local not in all_schemas_local: selected_schema_local = 'All' # Reset if invalid
        schema_index_local = all_schemas_local.index(selected_schema_local) if selected_schema_local in all_schemas_local else 0
        selected_schema_local = st.selectbox("Schema:", options=all_schemas_local, key="_dt_health_tab_schema_filter", index=schema_index_local, on_change=persist_local_widget_state, args=("dt_health_tab_schema_filter",))
        current_schema_filter_local = selected_schema_local

    with filter_cols_row1_local[2]: # Table(s) (depends on Schema)
        table_options_df_local = local_options_for_this_tab.copy()
        if current_schema_filter_local != 'All':
            table_options_df_local = table_options_df_local[table_options_df_local['SCHEMA_NAME'] == current_schema_filter_local]
        all_tables_local = ['All'] + sorted(table_options_df_local['TABLE_NAME'].unique().tolist())
        selected_tables_local = load_local_widget_state('dt_health_tab_table_filter', ['All'])
        valid_current_tables_local = [t for t in selected_tables_local if t in all_tables_local]
        if not valid_current_tables_local and 'All' in all_tables_local: valid_current_tables_local = ['All']
        elif not valid_current_tables_local: valid_current_tables_local = []
        selected_tables_local = st.multiselect("Table(s):", options=all_tables_local, key="_dt_health_tab_table_filter", default=valid_current_tables_local, on_change=persist_local_widget_state, args=("dt_health_tab_table_filter",))
        current_table_filter_local = selected_tables_local

    with filter_cols_row1_local[3]: # Scheduling State(s)
        all_scheduling_states_local = ['All'] + sorted(local_options_for_this_tab['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].unique().tolist())
        selected_sched_state_local = load_local_widget_state('dt_health_tab_scheduling_state_filter', ['All'])
        valid_current_sched_states_local = [s for s in selected_sched_state_local if s in all_scheduling_states_local]
        if not valid_current_sched_states_local and 'All' in all_scheduling_states_local: valid_current_sched_states_local = ['All']
        selected_sched_state_local = st.multiselect("Scheduling State(s):", options=all_scheduling_states_local, key="_dt_health_tab_scheduling_state_filter", default=valid_current_sched_states_local, on_change=persist_local_widget_state, args=("dt_health_tab_scheduling_state_filter",))
        current_scheduling_state_filter_local = selected_sched_state_local

    # --- Row 2 (Local): Domain Name, Sub Domain Name, Target Lag (seconds), Display Lag Times In ---
    with filter_cols_row2_local[0]: # Domain Name
        all_domains_local = ['All'] + sorted(local_options_for_this_tab['DOMAIN_NAME'].unique().tolist())
        selected_domain_local = load_local_widget_state('dt_health_tab_domain_name_filter', 'All')
        domain_index_local = all_domains_local.index(selected_domain_local) if selected_domain_local in all_domains_local else 0
        selected_domain_local = st.selectbox("Domain Name:", options=all_domains_local, key="_dt_health_tab_domain_name_filter", index=domain_index_local, on_change=persist_local_widget_state, args=("dt_health_tab_domain_name_filter",))
        current_domain_name_filter_local = selected_domain_local

    with filter_cols_row2_local[1]: # Sub Domain Name (depends on Domain Name)
        sub_domain_options_df_local = local_options_for_this_tab.copy()
        if current_domain_name_filter_local != 'All':
            sub_domain_options_df_local = sub_domain_options_df_local[sub_domain_options_df_local['DOMAIN_NAME'] == current_domain_name_filter_local]
        all_sub_domains_local = ['All'] + sorted(sub_domain_options_df_local['SUB_DOMAIN_NAME'].dropna().unique().tolist())
        selected_sub_domain_local = load_local_widget_state('dt_health_tab_sub_domain_name_filter', 'All')
        if selected_sub_domain_local not in all_sub_domains_local: selected_sub_domain_local = 'All' # Reset if invalid
        sub_domain_index_local = all_sub_domains_local.index(selected_sub_domain_local) if selected_sub_domain_local in all_sub_domains_local else 0
        selected_sub_domain_local = st.selectbox("Sub Domain Name:", options=all_sub_domains_local, key="_dt_health_tab_sub_domain_name_filter", index=sub_domain_index_local, on_change=persist_local_widget_state, args=("dt_health_tab_sub_domain_name_filter",))
        current_sub_domain_name_filter_local = selected_sub_domain_local

    with filter_cols_row2_local[2]: # Target Lag (seconds)
        all_target_lags_raw_local = local_options_for_this_tab['TARGET_LAG_SEC'].dropna().unique().tolist()
        all_target_lags_formatted_local = sorted([f"{int(x)}s" for x in all_target_lags_raw_local])
        all_target_lags_options_local = ['All'] + all_target_lags_formatted_local
        selected_target_lag_local = load_local_widget_state('dt_health_tab_target_lag_filter', ['All'])
        valid_current_target_lags_local = [l for l in selected_target_lag_local if l in all_target_lags_options_local]
        if not valid_current_target_lags_local and 'All' in all_target_lags_options_local: valid_current_target_lags_local = ['All']
        selected_target_lag_local = st.multiselect("Target Lag (seconds):", options=all_target_lags_options_local, key="_dt_health_tab_target_lag_filter", default=valid_current_target_lags_local, on_change=persist_local_widget_state, args=("dt_health_tab_target_lag_filter",))
        current_target_lag_filter_local = selected_target_lag_local

    with filter_cols_row2_local[3]: # Display Lag Times In
        all_time_formats_local = ["mixed", "seconds", "minutes", "hours", "days"]
        selected_time_format_local = load_local_widget_state('dt_health_tab_display_lag_times_in', 'mixed')
        time_format_index_local = all_time_formats_local.index(selected_time_format_local) if selected_time_format_local in all_time_formats_local else 0
        selected_time_format_local = st.radio("Display Lag Times In:", options=all_time_formats_local, index=time_format_index_local, horizontal=True, key="_dt_health_tab_display_lag_times_in", on_change=persist_local_widget_state, args=("dt_health_tab_display_lag_times_in",))
        current_display_lag_times_in_local = selected_time_format_local

    st.markdown("---")


    # --- Apply ALL Filters (Global + Local) to initial all_tracking_data_df ---
    # This `final_filtered_data_for_display` will be the base for all KPIs, Charts, and the Detailed Table
    final_filtered_data_for_display = all_tracking_data_df.copy()

    # Apply GLOBAL filters first
    global_domain_name_filter = st.session_state.get('global_domain_name', 'All')
    global_sub_domain_name_filter = st.session_state.get('global_sub_domain_name', 'All')
    global_db_filter = st.session_state.get('global_db_filter', 'All')
    global_schema_filter = st.session_state.get('global_schema_filter', 'All')
    global_table_filter = st.session_state.get('global_table_filter', ['All'])
    global_scheduling_state_filter = st.session_state.get('global_scheduling_state_filter', ['All'])
    global_target_lag_filter = st.session_state.get('global_target_lag', ['All'])
    global_is_active_filter = st.session_state.get('global_is_active_filter', 'All')


    if global_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DOMAIN_NAME'] == global_domain_name_filter]
    if global_sub_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SUB_DOMAIN_NAME'] == global_sub_domain_name_filter]
    if global_db_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DATABASE_NAME'] == global_db_filter]
    if global_schema_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SCHEMA_NAME'] == global_schema_filter]
    if 'All' not in global_table_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TABLE_NAME'].isin(global_table_filter)]
    if 'All' not in global_scheduling_state_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].isin(global_scheduling_state_filter)]
    if 'All' not in global_target_lag_filter:
        global_target_lag_values_numeric = [int(s.replace('s', '')) for s in global_target_lag_filter]
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TARGET_LAG_SEC'].isin(global_target_lag_values_numeric)]
    if global_is_active_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['IS_ACTIVE'] == global_is_active_filter]
    
    # Apply LOCAL filters (read from this tab's session_state keys)
    # Filter order matters for efficiency, but here we apply all to the combined DF
    if current_local_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DOMAIN_NAME'] == current_local_domain_name_filter]
    if current_local_sub_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SUB_DOMAIN_NAME'] == current_local_sub_domain_name_filter]
    if current_local_db_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DATABASE_NAME'] == current_local_db_filter]
    if current_local_schema_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SCHEMA_NAME'] == current_local_schema_filter]
    if 'All' not in current_local_table_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TABLE_NAME'].isin(current_local_table_filter)]
    if 'All' not in current_local_scheduling_state_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].isin(current_local_scheduling_state_filter)]
    if 'All' not in current_local_target_lag_filter:
        local_target_lag_values_numeric = [int(s.replace('s', '')) for s in current_local_target_lag_filter]
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TARGET_LAG_SEC'].isin(local_target_lag_values_numeric)]


    if final_filtered_data_for_display.empty:
        st.info("No tables match the combined global and local filter selections.", icon="ℹ️")
        return

    # Update tracking_data_df to be the final filtered one for KPIs and Charts
    tracking_data_df = final_filtered_data_for_display.copy()


    # --- 2. Overall Driver Health KPIs ---
    st.subheader("Overall Driver Health KPIs")
    kpi_cols = st.columns(4)

    latest_run = driver_history_df.iloc[0] if not driver_history_df.empty else None
    
    total_tables_tracked = tracking_data_df['QUALIFIED_NAME'].nunique() if not tracking_data_df.empty else 0
    active_rh_tracking = tracking_data_df[
        (tracking_data_df['IS_ACTIVE'] == True) & (tracking_data_df['TRACK_REFRESH_HISTORY'] == True)
    ].shape[0] if not tracking_data_df.empty else 0
    active_metadata_tracking = tracking_data_df[
        (tracking_data_df['IS_ACTIVE'] == True) & (tracking_data_df['TRACK_METADATA_SNAPSHOT'] == True)
    ].shape[0] if not tracking_data_df.empty else 0
    
    tables_not_refreshed_last_3_days = 0
    if not tracking_data_df.empty and 'LATEST_DATA_TIMESTAMP' in tracking_data_df.columns:
        three_days_ago = datetime.now() - timedelta(days=3)
        tables_not_refreshed_last_3_days = tracking_data_df[
            (tracking_data_df['LATEST_DATA_TIMESTAMP'].isna()) |
            (tracking_data_df['LATEST_DATA_TIMESTAMP'] < three_days_ago)
        ].shape[0]

    with kpi_cols[0]:
        st.metric("Total Tables Tracked", total_tables_tracked)
        st.metric("Active (RH) Tracking", active_rh_tracking)
    with kpi_cols[1]:
        st.metric("Active Tables Monitored", total_tables_tracked)
        st.metric("Active (Metadata) Tracking", active_metadata_tracking)
    with kpi_cols[2]:
        if latest_run is not None:
            st.metric("Last Driver Run Time", latest_run['RUN_END_TIME'].strftime('%Y-%m-%d %H:%M:%S'))
        else:
            st.metric("Last Driver Run Time", "N/A")
        st.metric("Tables Not Refreshed (last 3d)", tables_not_refreshed_last_3_days)
    with kpi_cols[3]:
        if latest_run is not None:
            duration_formatted = format_seconds_to_readable(
                pd.Series([latest_run['TOTAL_DURATION_SEC']]), "mixed"
            ).iloc[0]
            st.metric("Last Run Duration", duration_formatted)
        else:
            st.metric("Last Run Duration", "N/A")

    st.markdown("---")

    # --- 3. Driver Execution Time Trend Chart and Collection Status Distribution ---
    chart_row_cols = st.columns([0.6, 0.4])

    with chart_row_cols[0]: # Driver Execution Time Trend Chart (Left)
        st.subheader("Driver Execution Time Trend")
        st.write("Historical execution times of the main collection driver program.")
        if not driver_history_df.empty:
            driver_history_chart_data = driver_history_df.copy()
            driver_history_chart_data.rename(columns={
                'RUN_START_TIME': 'Run Time',
                'TOTAL_DURATION_SEC': 'Duration (seconds)'
            }, inplace=True)

            log_scale_y = st.checkbox("Log Scale Y-axis (Driver Trend)", value=False, key="log_scale_driver_trend")
            
            fig_trend = px.line(
                driver_history_chart_data,
                x='Run Time',
                y='Duration (seconds)',
                title='Driver Program Execution Duration Over Time',
                markers=True,
                log_y=log_scale_y
            )
            fig_trend.update_layout(hovermode="x unified")
            st.plotly_chart(fig_trend, use_container_width=True)
        else:
            st.info("No historical driver execution data for trend chart.", icon="ℹ️")

    with chart_row_cols[1]: # Collection Status Distribution (Right)
        st.subheader("Collection Status Distribution")
        st.write("Breakdown of tables by their last collection status for each type.")
        if not tracking_data_df.empty:
            rh_status_counts = tracking_data_df['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].value_counts().reset_index()
            rh_status_counts.columns = ['Status', 'Count']
            rh_status_counts['Collection Type'] = 'Refresh History'

            md_status_counts = tracking_data_df['LAST_METADATA_COLLECTION_STATUS'].value_counts().reset_index()
            md_status_counts.columns = ['Status', 'Count']
            md_status_counts['Collection Type'] = 'Metadata Snapshot'

            combined_status_counts = pd.concat([rh_status_counts, md_status_counts])

            status_color_map_for_chart = {
                'SUCCESS': 'green',
                'SUCCESS_NO_RECORDS': 'lightgreen',
                'FAILED': 'red',
                'FAILED_EXECUTION': 'red',
                'FAILED_INPUT': 'red',
                'FAILED_SUBMISSION': 'red',
                'SUSPENDED': 'orange',
                'UNKNOWN': 'gray',
                'N/A': 'lightgray'
            }

            fig_bar = px.bar(
                combined_status_counts,
                x='Count',
                y='Collection Type',
                color='Status',
                orientation='h',
                title='Last Collection Status by Type',
                color_discrete_map=status_color_map_for_chart,
                text='Count'
            )
            fig_bar.update_traces(textposition='outside')
            fig_bar.update_layout(showlegend=True, yaxis_title=None, xaxis_title='Number of Tables')
            st.plotly_chart(fig_bar, use_container_width=True)
        else:
            st.info("No detailed tracking data for status distribution.", icon="ℹ️")
    
    st.markdown("---")

    # --- 4. Detailed Collection Status per Table (with local filtering) ---
    st.subheader("Detailed Collection Status per Table")
    st.write("View the last collection attempt status and messages for each dynamic table being tracked.")

    # Local filter options are derived from the already globally-filtered tracking_data_df
    local_options_for_this_tab = tracking_data_df.copy()

    if local_options_for_this_tab.empty:
        st.info("No detailed collection status per table available.", icon="ℹ️")
        return

    # Filter section for local filters
    filter_cols_row1_local = st.columns(4) # Database, Schema, Table(s), Scheduling State(s)
    filter_cols_row2_local = st.columns(4) # Domain Name, Sub Domain Name, Target Lag (seconds), Display Lag Times In

    # --- Row 1 (Local): Database, Schema, Table(s), Scheduling State(s) ---
    # Apply local_options_for_this_tab as the base for all options in this section.
    
    # Domain Name -> Sub Domain -> Database -> Schema -> Table
    # Start filtering options_df to pass to selectboxes
    options_df_domain_for_cascade = local_options_for_this_tab.copy()

    with filter_cols_row2_local[0]: # Domain Name (Parent)
        all_domains_local = ['All'] + sorted(options_df_domain_for_cascade['DOMAIN_NAME'].unique().tolist())
        selected_domain_local_val = load_local_widget_state('dt_health_tab_domain_name_filter', 'All')
        # Check if stored value is still valid in current options list, otherwise reset
        if selected_domain_local_val not in all_domains_local: selected_domain_local_val = 'All'
        domain_index_local = all_domains_local.index(selected_domain_local_val)
        selected_domain_local = st.selectbox("Domain Name:", options=all_domains_local, key="_dt_health_tab_domain_name_filter", index=domain_index_local, on_change=persist_local_widget_state, args=("dt_health_tab_domain_name_filter",))
        # Update current for cascading to children
        current_domain_name_filter_local = selected_domain_local
        # Filter data for next dropdown in cascade
        if current_domain_name_filter_local != 'All':
            options_df_domain_for_cascade = options_df_domain_for_cascade[options_df_domain_for_cascade['DOMAIN_NAME'] == current_domain_name_filter_local]

    with filter_cols_row2_local[1]: # Sub Domain Name (depends on Domain Name)
        all_sub_domains_local = ['All'] + sorted(options_df_domain_for_cascade['SUB_DOMAIN_NAME'].dropna().unique().tolist())
        selected_sub_domain_local_val = load_local_widget_state('dt_health_tab_sub_domain_name_filter', 'All')
        if selected_sub_domain_local_val not in all_sub_domains_local: selected_sub_domain_local_val = 'All'
        sub_domain_index_local = all_sub_domains_local.index(selected_sub_domain_local_val)
        selected_sub_domain_local = st.selectbox("Sub Domain Name:", options=all_sub_domains_local, key="_dt_health_tab_sub_domain_name_filter", index=sub_domain_index_local, on_change=persist_local_widget_state, args=("dt_health_tab_sub_domain_name_filter",))
        current_sub_domain_name_filter_local = selected_sub_domain_local
        # Filter data for next dropdown in cascade
        if current_sub_domain_name_filter_local != 'All':
            options_df_domain_for_cascade = options_df_domain_for_cascade[options_df_domain_for_cascade['SUB_DOMAIN_NAME'] == current_sub_domain_name_filter_local]

    with filter_cols_row1_local[0]: # Database (depends on Sub Domain Name)
        all_databases_local = ['All'] + sorted(options_df_domain_for_cascade['DATABASE_NAME'].unique().tolist())
        selected_db_local_val = load_local_widget_state('dt_health_tab_db_filter', 'All')
        if selected_db_local_val not in all_databases_local: selected_db_local_val = 'All'
        db_index_local = all_databases_local.index(selected_db_local_val)
        selected_db_local = st.selectbox("Database:", options=all_databases_local, key="_dt_health_tab_db_filter", index=db_index_local, on_change=persist_local_widget_state, args=("dt_health_tab_db_filter",))
        current_db_filter_local = selected_db_local
        # Filter data for next dropdown in cascade
        if current_db_filter_local != 'All':
            options_df_domain_for_cascade = options_df_domain_for_cascade[options_df_domain_for_cascade['DATABASE_NAME'] == current_db_filter_local]

    with filter_cols_row1_local[1]: # Schema (depends on Database)
        all_schemas_local = ['All'] + sorted(options_df_domain_for_cascade['SCHEMA_NAME'].unique().tolist())
        selected_schema_local_val = load_local_widget_state('dt_health_tab_schema_filter', 'All')
        if selected_schema_local_val not in all_schemas_local: selected_schema_local_val = 'All'
        schema_index_local = all_schemas_local.index(selected_schema_local_val)
        selected_schema_local = st.selectbox("Schema:", options=all_schemas_local, key="_dt_health_tab_schema_filter", index=schema_index_local, on_change=persist_local_widget_state, args=("dt_health_tab_schema_filter",))
        current_schema_filter_local = selected_schema_local
        # Filter data for next dropdown in cascade
        if current_schema_filter_local != 'All':
            options_df_domain_for_cascade = options_df_domain_for_cascade[options_df_domain_for_cascade['SCHEMA_NAME'] == current_schema_filter_local]

    with filter_cols_row1_local[2]: # Table(s) (depends on Schema)
        all_tables_local = ['All'] + sorted(options_df_domain_for_cascade['TABLE_NAME'].unique().tolist())
        selected_tables_local_val = load_local_widget_state('dt_health_tab_table_filter', ['All'])
        valid_current_tables_local = [t for t in selected_tables_local_val if t in all_tables_local]
        if not valid_current_tables_local and 'All' in all_tables_local: valid_current_tables_local = ['All']
        selected_tables_local = st.multiselect("Table(s):", options=all_tables_local, key="_dt_health_tab_table_filter", default=valid_current_tables_local, on_change=persist_local_widget_state, args=("dt_health_tab_table_filter",))
        current_table_filter_local = selected_tables_local


    with filter_cols_row1_local[3]: # Scheduling State(s) (Independent of cascading DB/Schema/Table chain)
        # Options are always derived from the ALL initial data, not the cascaded data
        all_scheduling_states_local = ['All'] + sorted(all_tracking_data_df['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].unique().tolist())
        selected_sched_state_local_val = load_local_widget_state('dt_health_tab_scheduling_state_filter', ['All'])
        valid_current_sched_states_local = [s for s in selected_sched_state_local_val if s in all_scheduling_states_local]
        if not valid_current_sched_states_local and 'All' in all_scheduling_states_local: valid_current_sched_states_local = ['All']
        selected_sched_state_local = st.multiselect("Scheduling State(s):", options=all_scheduling_states_local, key="_dt_health_tab_scheduling_state_filter", default=valid_current_sched_states_local, on_change=persist_local_widget_state, args=("dt_health_tab_scheduling_state_filter",))
        current_scheduling_state_filter_local = selected_sched_state_local

    with filter_cols_row2_local[2]: # Target Lag (seconds) (Independent of cascading chain)
        # Options derived from ALL initial data
        all_target_lags_raw_local = all_tracking_data_df['TARGET_LAG_SEC'].dropna().unique().tolist()
        all_target_lags_formatted_local = sorted([f"{int(x)}s" for x in all_target_lags_raw_local])
        all_target_lags_options_local = ['All'] + all_target_lags_formatted_local
        selected_target_lag_local_val = load_local_widget_state('dt_health_tab_target_lag_filter', ['All'])
        valid_current_target_lags_local = [l for l in selected_target_lag_local_val if l in all_target_lags_options_local]
        if not valid_current_target_lags_local and 'All' in all_target_lags_options_local: valid_current_target_lags_local = ['All']
        selected_target_lag_local = st.multiselect("Target Lag (seconds):", options=all_target_lags_options_local, key="_dt_health_tab_target_lag_filter", default=valid_current_target_lags_local, on_change=persist_local_widget_state, args=("dt_health_tab_target_lag_filter",))
        current_target_lag_filter_local = selected_target_lag_local

    with filter_cols_row2_local[3]: # Display Lag Times In (Independent Radio Button)
        all_time_formats_local = ["mixed", "seconds", "minutes", "hours", "days"]
        selected_time_format_local_val = load_local_widget_state('dt_health_tab_display_lag_times_in', 'mixed')
        time_format_index_local = all_time_formats_local.index(selected_time_format_local_val) if selected_time_format_local_val in all_time_formats_local else 0
        selected_time_format_local = st.radio("Display Lag Times In:", options=all_time_formats_local, index=time_format_index_local, horizontal=True, key="_dt_health_tab_display_lag_times_in", on_change=persist_local_widget_state, args=("dt_health_tab_display_lag_times_in",))
        current_display_lag_times_in_local = selected_time_format_local


    st.markdown("---")


    # --- Apply ALL Filters (Global + Local) to initial all_tracking_data_df ---
    # This `final_filtered_data_for_display` will be the base for all KPIs, Charts, and the Detailed Table
    final_filtered_data_for_display = all_tracking_data_df.copy()

    # Apply GLOBAL filters first (read from session_state)
    global_domain_name_filter = st.session_state.get('global_domain_name', 'All')
    global_sub_domain_name_filter = st.session_state.get('global_sub_domain_name', 'All')
    global_db_filter = st.session_state.get('global_db_filter', 'All')
    global_schema_filter = st.session_state.get('global_schema_filter', 'All')
    global_table_filter = st.session_state.get('global_table_filter', ['All'])
    global_scheduling_state_filter = st.session_state.get('global_scheduling_state_filter', ['All'])
    global_target_lag_filter = st.session_state.get('global_target_lag', ['All'])
    global_is_active_filter = st.session_state.get('global_is_active_filter', 'All')


    if global_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DOMAIN_NAME'] == global_domain_name_filter]
    if global_sub_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SUB_DOMAIN_NAME'] == global_sub_domain_name_filter]
    if global_db_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DATABASE_NAME'] == global_db_filter]
    if global_schema_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SCHEMA_NAME'] == global_schema_filter]
    if 'All' not in global_table_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TABLE_NAME'].isin(global_table_filter)]
    if 'All' not in global_scheduling_state_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].isin(global_scheduling_state_filter)]
    if 'All' not in global_target_lag_filter:
        global_target_lag_values_numeric = [int(s.replace('s', '')) for s in global_target_lag_filter]
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TARGET_LAG_SEC'].isin(global_target_lag_values_numeric)]
    if global_is_active_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['IS_ACTIVE'] == global_is_active_filter]
    
    # Apply LOCAL filters (read from this tab's session_state keys)
    # Ensure they are applied in the correct cascading order if they interact, OR after all independent filters.
    # We'll apply them based on the current_local_..._filter variables which already hold the user's latest selection
    
    # Filtering based on local domain/sub_domain hierarchy
    if current_local_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DOMAIN_NAME'] == current_local_domain_name_filter]
    if current_local_sub_domain_name_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SUB_DOMAIN_NAME'] == current_local_sub_domain_name_filter]

    # Filtering based on local database/schema/table hierarchy
    if current_local_db_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['DATABASE_NAME'] == current_local_db_filter]
    if current_local_schema_filter != 'All':
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['SCHEMA_NAME'] == current_local_schema_filter]
    if 'All' not in current_local_table_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TABLE_NAME'].isin(current_local_table_filter)]
    
    # Independent local filters
    if 'All' not in current_local_scheduling_state_filter:
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['LAST_REFRESH_HISTORY_COLLECTION_STATUS'].isin(current_local_scheduling_state_filter)]
    if 'All' not in current_local_target_lag_filter:
        local_target_lag_values_numeric = [int(s.replace('s', '')) for s in current_local_target_lag_filter]
        final_filtered_data_for_display = final_filtered_data_for_display[final_filtered_data_for_display['TARGET_LAG_SEC'].isin(local_target_lag_values_numeric)]


    if final_filtered_data_for_display.empty:
        st.info("No tables match the combined global and local filter selections.", icon="ℹ️")
        return

    # Update tracking_data_df to be the final filtered one for KPIs and Charts
    tracking_data_df = final_filtered_data_for_display.copy()


    # ... (KPIs section, Charts section, Detailed Table section - all use `tracking_data_df` and `current_display_lag_times_in_local`) ...

    # Example of adjusting column formatting for detailed table using current_display_lag_times_in_local
    display_df = tracking_data_df.copy()

    # Apply time formatting here based on current_display_lag_times_in_local
    if 'MEAN_LAG_SEC' in display_df.columns:
        display_df['MEAN_LAG_SEC_FMT'] = format_seconds_to_readable(display_df['MEAN_LAG_SEC'], current_display_lag_times_in_local)
    if 'MAXIMUM_LAG_SEC' in display_df.columns:
        display_df['MAXIMUM_LAG_SEC_FMT'] = format_seconds_to_readable(display_df['MAXIMUM_LAG_SEC'], current_display_lag_times_in_local)
    if 'TARGET_LAG_SEC' in display_df.columns:
        display_df['TARGET_LAG_SEC_FMT'] = format_seconds_to_readable(display_df['TARGET_LAG_SEC'], current_display_lag_times_in_local)


    display_df['LAST_RH_COLLECT_TIME'] = display_df['LAST_REFRESH_HISTORY_COLLECTION_TIMESTAMP'].dt.strftime('%Y-%m-%d %H:%M:%S')
    display_df['LAST_MD_COLLECT_TIME'] = display_df['LAST_METADATA_COLLECTION_TIMESTAMP'].dt.strftime('%Y-%m-%d %H:%M:%S')
    display_df['LATEST_DATA_TIMESTAMP_FMT'] = display_df['LATEST_DATA_TIMESTAMP'].dt.strftime('%Y-%m-%d %H:%M:%S')
    display_df['TRACKING_RECORD_LAST_UPDATED'] = display_df['UPDATED_AT'].dt.strftime('%Y-%m-%d %H:%M:%S')

    display_df = display_df.drop(columns=[
        'LAST_REFRESH_HISTORY_COLLECTION_MESSAGE', 
        'LAST_METADATA_COLLECTION_MESSAGE'
    ], errors='ignore') 

    display_df = display_df.rename(columns={
        'QUALIFIED_NAME': 'Dynamic Table',
        'IS_ACTIVE': 'Active?',
        'TRACK_REFRESH_HISTORY': 'Track RH?',
        'LAST_REFRESH_HISTORY_COLLECTION_STATUS': 'Last RH Status',
        'TRACK_METADATA_SNAPSHOT': 'Track Metadata?',
        'LAST_METADATA_COLLECTION_STATUS': 'Last Metadata Status',
        'LAST_RH_COLLECT_TIME': 'Last RH Collect Time',
        'LAST_MD_COLLECT_TIME': 'Last Metadata Collect Time',
        'LATEST_DATA_TIMESTAMP': 'Latest Data Time',
        'UPDATED_AT': 'Tracking Record Last Updated'
    })

    final_cols_order = [
        'Dynamic Table',
        'Active?',
        'Track RH?',
        'Last RH Collect Time',
        'Last RH Status',
        'Track Metadata?',
        'Last Metadata Collect Time',
        'Last Metadata Status',
        'Latest Data Time',
        'MEAN_LAG_SEC_FMT',
        'MAXIMUM_LAG_SEC_FMT',
        'TARGET_LAG_SEC_FMT',
        'Tracking Record Last Updated'
    ]

    final_display_df = display_df[[col for col in final_cols_order if col in display_df.columns]]

    st.dataframe(final_display_df, use_container_width=True)
